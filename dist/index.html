
<html>
<head>
  <title>PSPDFKit Document Comparison V3</title>
</head>
<style>
  #viewer-container {
    display: flex;
    height: 100vh;
  }

  #viewer-container > div {
    width: 50%;
    height: 100%;
  }
</style>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

  <script src="./assets/pspdfkit.js"></script>
  <div id="viewer-container">
    <div id="pspdfkitLeft"></div>
    <div id="pspdfkitRight"></div>
  </div>


  <script>

    let licenseKey = 'vCR5dwIXsXHZsHQoufWEefkm8URHmt9zBymfQ5rWYpggjx_xYADpAXOHYxcdt_PbwurRb_c52uN5BrbRl0ta5wnVrcTnfSM4jASkm6QuPPiuhEI0xdglf_s-V-4aFMCK9u9XT0vJ3XPU4zyiMdem6Wd5sNvUEfP_fWPsbm1DnRMAJJl3vmXshBTlGtjlJYXwNn69OkOq6K9q7qGFHIx95iCXSQLSjRfpyEtWr0wjwLlUykC7tIt9qX8oGO-STn6hplnJzRWRFs_EdP4-YqzcLMaaY-GMKnOUSU5wrThJ7Bb6LJEWBTRX2XraeB6UFqM0rwMqcso8CnoDq1l3Qn_aNZS_6wmcj3K1azVL8NuMyBmu87nwzwlegvXjSqWIXHptd_FUqXX3Npze4CymDYNoRJuJy8s3bv1ikBvXkMKwQR8d1ayy8fs9tzcRyWamyzfzsCNjv1duLSGIkluTxIZMeYU2hd3nsFsFY7Bnot2MLGZI2udJ7iIFTx3QBS_zRFdQjJ_FLl9viOFVtjG_Rklfzqvn2675leoU7de7DBUOnUWQk8oZRUAvMmber1GzORnKeE1M37Wd5YxS20tQYrjRNr0BdaTOMEUshCyCI1EEjWrCy_zdlng2l2jZtrlYZkNsEwiGz8Cvn9UtmgVHg0UQPfzDYB8tk7Hv51rh5RR9xEllaFZMc82py7G_GjSHIRLyKJWiD_eaHbWxPEnzZszNhmqpA6Jx4Y-jVAPE-bub3LG6dd5nfzCHlbMOJTiNPHrSayPmX3QRTV14MpDcyRu8uZGhalXvx3IYcMPx_SLEXattbzdcT6OWH6nFmmrztq63pJ2IgnfDbeZ0XlarWKu0SYEMAq8fBl41tFFVYdztD6PU2qULlY3SyTQyL_FnQxw4oSgFTBXeyr80Mlj03FZf710WxYF1-JuWUQq4GlOlknuXqmVdjgCF4R__lKm0IPr0xCvTq4r5f9t7zXP3LT12QcQ5QtRXPi6By11pZMkTlKGbfzRbDuf2ksVAMhOSuPmYf3C-xZBdPGvm6r95ltSFxIdYNILrwJ2IjYs2RW3JxDWFpwK4MYpEiADzQP3SiKBgqKncfTcInoFmd5kM8mFddavDbw4uoaNLIUaSXphq_qgucHk5LQP7sHFjzfqVVWxYR_U6_NUZyvpUn-1Wv6YO9K5JzeR-lnCTxOxPIE-iA01qDhj2lZ-sJYy_zK0D19uPk9b8agtDudqWlQPebCtc6cHpfe3Wq16rlwiFheL4pVI=';

    let leftViewer, rightViewer;
    let defaultItemsLeft = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsLeft.pop();
    
    let defaultItemsRight = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsRight.pop();

    const uploadLeft = {
      type: "custom",
      id: "UploadLeft",
      title: "Upload Left Document",
      onPress: (event) => {
        if(leftViewer){
            // Create a new file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';

            // Listen for changes to the file input element
            fileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];

              // Unload the old document
              PSPDFKit.unload("#pspdfkitLeft");

              // Read the file
              const reader = new FileReader();
              reader.onload = async (event) => {
                // Load the new document
                leftViewer = await PSPDFKit.load({
                  container: "#pspdfkitLeft",
                  document: event.target.result,
                  toolbarItems: defaultItemsLeft,
                  licenseKey: licenseKey
                });

                // Delete all annotations in the other viewer
                // and compare the documents again.
                const totalPageCount = rightViewer.totalPageCount;
                for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                  const annotations = await rightViewer.getAnnotations(pageIndex);
                  rightViewer.delete(annotations);
                }
                
                // Add event listeners for the left viewer to sync its state to the right viewer
                let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
                scrollElement.addEventListener("scroll", syncViewStateLeft);

                // TODO: Needed when viewer is in single page mode
                //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
                leftViewer.addEventListener("viewState.zoom.change", syncViewStateLeft);

                compareText(leftViewer, rightViewer);
              };
              reader.readAsArrayBuffer(file);
            });

            // Open the file selector
            fileInput.click();
          }
      }
    };

    const uploadRight = {
      type: "custom",
      id: "UploadRight",
      title: "Upload Right Document",
      onPress: (event) => {
        if(rightViewer){
          // Create a new file input element
          const fileInput = document.createElement('input');
          fileInput.type = 'file';

          // Listen for changes to the file input element
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            // Unload the old document
            PSPDFKit.unload("#pspdfkitRight");

            // Read the file
            const reader = new FileReader();
            reader.onload = async (event) => {
              // Load the new document
              rightViewer = await PSPDFKit.load({
                container: "#pspdfkitRight",
                document: event.target.result,
                toolbarItems: defaultItemsRight,
                licenseKey: licenseKey
              });
              // Delete all annotations in the other viewer
              // and compare the documents again.
              const totalPageCount = leftViewer.totalPageCount;
              for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                const annotations = await leftViewer.getAnnotations(pageIndex);
                leftViewer.delete(annotations);
              }

              let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
              scrollElement.addEventListener("scroll", syncViewStateRight);
        
              // TODO: Needed when viewer is in single page mode
              //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
              rightViewer.addEventListener("viewState.zoom.change", syncViewStateRight);

              compareText(leftViewer, rightViewer);
            };
            reader.readAsArrayBuffer(file);
          });

          // Open the file selector
          fileInput.click();
        }
      }
    };

    defaultItemsLeft.push(uploadLeft);
    defaultItemsRight.push(uploadRight);

    function getFormattedGlyps(glyphs){

      function truncateNumbers(obj) {
        if (typeof obj === "number") {
          return parseFloat(obj.toFixed(0));
        } else if (typeof obj === "object" && obj !== null) {
          if (Array.isArray(obj)) {
            return obj.map(item => truncateNumbers(item));
          } else {
            const newObj = {};
            for (const key in obj) {
              newObj[key] = truncateNumbers(obj[key]);
            }
            return newObj;
          }
        }
        return obj;
      }
    
      // Assuming you have the flattened array
      const flattenedArray = glyphs.toArray();
    
      // Truncate numbers to two decimal points
      const truncatedArray = truncateNumbers(flattenedArray);
    
      // Convert the truncated array to a JSON string
      const jsonString = JSON.stringify(truncatedArray);
    
      // Log or use the JSON string as needed
      //console.log(jsonString);
  

      const optimizedJson = truncatedArray.map(item => {
        const { c, rect } = item;
        let width = rect.get("width");
        let height = rect.get("height");
        let top = rect.get("top");
        let left = rect.get("left");
        return { c, width, height, top, left };
      });

      return optimizedJson;
    
      //console.log(JSON.stringify(optimizedJson, null, 2));
    
      // Create the formatted string
      /*let result = '';
      for (const item of optimizedJson) {
        const char = item.c;
        const left = truncateNumbers(item.rect.toJS().left);
        const top = truncateNumbers(item.rect.toJS().top);
        const width = truncateNumbers(item.rect.toJS().width);
        const height = truncateNumbers(item.rect.toJS().height);
    
        //result += `${char},${left},${top};`;
        // Check for newline or carriage return and replace with their names
        if (char === '\n') {
          result += `\n,${left},${top},${width},${height};`;
        } else if (char === '\r') {
          result += `\r,${left},${top},${width},${height};`;
        } else {
           result += `${char},${left},${top},${width},${height};`;
           //result += `${char},${width};`;
        }
      }
    
      // Remove the trailing semicolon
      result = result.slice(0, -1);
      return result;*/
    }

    async function compareTextAI(instance1, instance2) {

      //new { left: 84.21, bottom: 103.28, right: 114.21, top: 77.28, width: 30, height: 26 }
      /*let annotation1 = new PSPDFKit.Annotations.HighlightAnnotation({
        pageIndex: 0,  
        color : new PSPDFKit.Color({ r: 255, g: 0, b: 0 }),
        boundingBox: new PSPDFKit.Geometry.Rect({
          left:  84.21, 
          bottom: 103.28, 
          right: 114.21, 
          top: 77.28,
        width: 30,
      height: 26 }),
        rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({
          left: 84.21, 
          bottom: 103.28, 
          right: 114.21, 
          top: 77.28,
          width: 30,
          height: 26 }),
      
      ])
      });
      await instance1.create(annotation1);

      // new: { left: 109.21, bottom: 103.28, right: 123.21, top: 77.28, width: 14, height: 26 }
      let annotation2 = new PSPDFKit.Annotations.HighlightAnnotation({
        pageIndex: 0,  
        color : new PSPDFKit.Color({ r: 255, g: 0, b: 0 }),
        boundingBox: new PSPDFKit.Geometry.Rect({
          left: 109.21,
          bottom: 103.28, 
          right:  123.21, 
          top: 77.28,
          width: 14,
      height: 26 }),
        rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({
          left: 109.21, 
          bottom: 103.28, 
          right:  123.21, 
          top: 77.28,
        width: 14,
      height: 26 }),
      
      ])
      });
      await instance1.create(annotation2);

      //{left: 298.73, bottom: 103.28, right: 335.68, top: 77.28, width: 36.95, height: 26 }
      let annotation3 = new PSPDFKit.Annotations.HighlightAnnotation({
        pageIndex: 0,  
        color : new PSPDFKit.Color({ r: 255, g: 0, b: 0 }),
        boundingBox: new PSPDFKit.Geometry.Rect({
          left: 298.73,
          bottom: 103.28, 
          right:  335.68, 
          top: 77.28,
          width: 36.95,
      height: 26 }),
        rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({
          left: 298.73, 
          bottom: 103.28, 
          right:  335.68, 
          top: 77.28,
        width: 36.95,
      height: 26 }),
      
      ])
      });
      await instance1.create(annotation3);*/

    
      // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);
      let linesInstance1 = await instance1.textLinesForPageIndex(0);
      console.log("lines 1");
      console.log(linesInstance1);
      let linesInstance2 = await instance2.textLinesForPageIndex(0);
      console.log("lines 2");
      console.log(linesInstance2);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

      console.log("Instance 1: " + glyphFormatted1);
     console.log("Instance 2: " + glyphFormatted2);

     const instructions = "your job is to parse two CSVs and compare them, they have the following format: <character>,<top position>,<left position>,<width>,<height> put the words and sentences based on the character together, the characters are in reading order. for example this P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10; translates to 'PDFs' after parsing both CSVs, compare the text of both CSVs and tell me if there are differences. your output should be in teh format of pspdfkit web highlight annotations. i want to create as few highlight annotations as possible to show all changes in the document. remember that th format for pspdfkit highlight annotations is as follows: {pageIndex: 0,rects: boundingBoxes,boundingBox: PSPDFKit.Geometry.Rect.union(boundingBoxes)} please group highlight annotations for neighbouring changed characters together into one as long as they are in the same word, don't list them as seperate rects in an array, but actually calculate one new rect. here is an example annotation  { pageIndex: 0, color : new PSPDFKit.Color({ r: 0, g: 255, b: 255 }), boundingBox: new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 }), rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 })]) }); your output should be strictly a json object with array element for each highlight annotation containing only the left, bottom, right, top, width and height property for each annotation only, without new lines \n or any other text, for example: { 'left': 74, 'bottom': 92, 'right': 112, 'top': 79, 'width': 38, 'height': 13 } start the annotation json with this keyword: 'annot:'" ;
     const userContent = "CSV1: P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;i,133,78,2,13;t,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;CSV2: P,74,79,8,13;B,84,79,10,13;A,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;x,133,78,2,13;g,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;";


      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer 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'
        },
        body: JSON.stringify({
          "model": "gpt-4",
          "temperature": 0,
          "messages": [
          {
            "role": "system",
            "content": instructions,
          },
            {
              "role": "user",
              "content": "CSV1: " + glyphFormatted1 + " CSV2: " + glyphFormatted2,
              //"content": userContent,
            }
          ]
        })
      })
      .then(async response => {
        let resp = await response.json();
        console.log(resp);
        let message = resp["choices"][0]["message"]["content"];
        console.log(message);

        // Extract the JSON part from the string
        let jsonPart = message.split("annot:")[1];
        jsonPart = jsonPart.replace(/'/g, '"');
        console.log("json part: ");
        console.log(jsonPart);

        const regex = /annot: {.*?}(?=\n|$)/g;
        const annotations = [];

        let match;
        while ((match = regex.exec(message)) !== null) {
            // Remove the "annot: " prefix and parse the JSON
            const jsonPart = match[0].replace("annot: ", "");
            try {
                const parsed = JSON.parse(jsonPart.replace(/'/g, "\"")); // Replacing single quotes with double quotes
                annotations.push(parsed);
            } catch (err) {
                console.error("Failed to parse JSON", err);
            }
        }

        console.log(annotations);

        // Parse the JSON part to a JavaScript object
        //let jsonArray = JSON.parse(jsonPart);

        if (!Array.isArray(annotations)) {
          annotations = [annotations];
      }

        // Loop through each JSON element and create a new HighlightAnnotation
        annotations.forEach(rect => {
          let annotation = new PSPDFKit.Annotations.HighlightAnnotation({
            pageIndex: 0,
            color: new PSPDFKit.Color({ r: 0, g: 255, b: 255 }),
            boundingBox: new PSPDFKit.Geometry.Rect({
              left: rect.left,
              bottom: rect.bottom,
              right: rect.right,
              top: rect.top,
              width: rect.width,
              height: rect.height
            }),
            rects: new PSPDFKit.Immutable.List([
              new PSPDFKit.Geometry.Rect({
                left: rect.left,
                bottom: rect.bottom,
                right: rect.right,
                top: rect.top,
                width: rect.width,
                height: rect.height
              })
            ])
          });
          // Use your PSPDFKit instance to create the annotation
          // Replace 'instance1' with your actual instance name
          instance1.create(annotation)
            .then(() => {
              console.log("Annotation created");
            })
            .catch(err => {
              console.error("Error creating annotation:", err);
            });
        });


        // Now `annotations` is an array of objects that you can import into PSPDFKit
        //console.log("creating this annot");
        //console.log(annotations);
        

        //wait instance1.create(annotations);
        //console.log("annot created");
      })
      .then(data => console.log(data))
      .catch((error) => console.error('Error:', error));

      //{left: 83.52, bottom: 103.28, right: 111.46, top: 77.28, width: 27.94, height: 26 }
      //{left: 167.43, bottom: 103.28, right: 186.06, top: 77.28, width: 18.63, height: 26 }
      

      //console.log("annot created");


    }

    async function compareTextAI2(instance1, instance2) {
      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
        const jsObj1 = textLines1.toJS();
        const jsonString1 = JSON.stringify(jsObj1);
        console.log(jsonString1);

        const jsObj2 = textLines2.toJS();
        const jsonString2 = JSON.stringify(jsObj2);
        console.log(jsonString2);
      }
    }

    async function compareText2(instance1, instance2){
     
      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;

              // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

      console.log("Instance 1: ");
      console.log(glyphFormatted1);
      console.log("Instance 2: ");
      console.log(glyphFormatted2);

      function textCompare(glyphs1, glyphs2) {
        const N = glyphs1.length;
        const M = glyphs2.length;
        const MAX = N + M;
        const V = new Array(2 * MAX + 1).fill(0);
      
        const trace = [];
      
        for (let D = 0; D <= MAX; D++) {
          for (let k = -D; k <= D; k += 2) {
            let x = (k === -D || (k !== D && V[MAX + k - 1] < V[MAX + k + 1])) ? V[MAX + k + 1] : V[MAX + k - 1] + 1;
            let y = x - k;
      
            while (x < N && y < M && glyphs1[x].c === glyphs2[y].c) {
              x++;
              y++;
            }
      
            V[MAX + k] = x;
      
            if (x >= N && y >= M) {
              return buildDiff(trace, glyphs1, glyphs2);
            }
          }
      
          trace.push([...V]);
        }
      }
      
      function buildDiff(trace, glyphs1, glyphs2) {
        const result = [];
        let x = glyphs1.length;
        let y = glyphs2.length;
        const MAX = x + y;
        let D = trace.length - 1;
      
        for (; D >= 0; D--) {
          const V = trace[D];
          const k = x - y;
      
          let prev_k = (k === -D || (k !== D && V[MAX + k - 1] < V[MAX + k + 1])) ? k + 1 : k - 1;
          let prev_x = V[MAX + prev_k];
          let prev_y = prev_x - prev_k;
      
          while (x > prev_x && y > prev_y) {
            result.push({
              action: 'EQUAL',
              char: glyphs1[x - 1].c,
              position1: glyphs1[x - 1],
              position2: glyphs2[y - 1]
            });
            x--;
            y--;
          }
      
          if (D === 0) break;
      
          for (; x > prev_x; x--) {
            result.push({
              action: 'DELETE',
              char: glyphs1[x - 1].c,
              position: glyphs1[x - 1]
            });
          }
      
          for (; y > prev_y; y--) {
            result.push({
              action: 'INSERT',
              char: glyphs2[y - 1].c,
              position: glyphs2[y - 1]
            });
          }
      
          x = prev_x;
          y = prev_y;
        }
      
        return result.reverse();
      }
      
      async function getLineForGlyph(glyph, pageIndex, instance) {
        const lines = await instance.textLinesForPageIndex(pageIndex);
        return lines.find(line =>
          glyph.top >= line.boundingBox.top &&
          glyph.top + glyph.height <= line.boundingBox.top + line.boundingBox.height
        );
      }

      const result = textCompare(glyphFormatted1, glyphFormatted2);
      console.log("result of comparison");
      console.log(result);

      let lastLine = null;
      let lastAction = null;
      let highlightGroup = [];
    
      for (const diff of result) {
        if (diff.action === 'INSERT' || diff.action === 'DELETE') {
          const glyph = diff.position;
          const line = await getLineForGlyph(glyph, pageIndex, diff.action === 'INSERT' ? instance2 : instance1);
          const instance = diff.action === 'INSERT' ? instance2 : instance1;
    
          // Check if the line is defined
          if (line) {
            if (lastLine && lastAction === diff.action && line.boundingBox.top === lastLine.boundingBox.top) {
              // Extend the current highlight group
              highlightGroup.push(glyph);
            } else {
              // Create a highlight annotation for the previous group
              if (highlightGroup.length > 0 && lastLine) {
                createHighlightAnnotation(highlightGroup, lastLine, lastAction, pageIndex, instance1, instance2);
              }
              // Start a new highlight group
              highlightGroup = [glyph];
              lastAction = diff.action;
              lastLine = line;
            }
          }
        }
      }
    
      // Create a highlight annotation for the last group
      if (highlightGroup.length > 0 && lastLine) {
        createHighlightAnnotation(highlightGroup, lastLine, lastAction, pageIndex, instance1, instance2);
      }
    
      function createHighlightAnnotation(highlightGroup, lastLine, lastAction, pageIndex, instance1, instance2) {
        const startGlyph = highlightGroup[0];
        const endGlyph = highlightGroup[highlightGroup.length - 1];
    
        const newBoundingBox = new PSPDFKit.Geometry.Rect({
          top: lastLine.boundingBox.top,
          left: startGlyph.left,
          width: endGlyph.left + endGlyph.width - startGlyph.left,
          height: lastLine.boundingBox.height,
        });
    
        const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
          boundingBox: newBoundingBox,
          pageIndex,
          color: lastAction === 'INSERT' ? PSPDFKit.Color.GREEN : PSPDFKit.Color.RED,
          opacity: 0.8,
          rects: PSPDFKit.Immutable.List.of(newBoundingBox),
        });
    
        // Add to the correct instance based on action
        const instanceToAdd = (lastAction === 'DELETE') ? instance1 : instance2;
        instanceToAdd.create(highlightAnnotation);
      }

      }

    }

    async function compareText3(instance1, instance2){
      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      function buildTextStructure(pageLines, characters) {
        const structure = [];
    
        function isCharInLine(char, line) {
            return char.top >= line.boundingBox.top && char.top <= line.boundingBox.bottom;
        }
    
        for (const line of pageLines) {
            const lineStructure = {
                lineText: line.contents,
                boundingBox: line.boundingBox,
                words: []
            };
    
            let wordsFromLineText = line.contents.split(/\s+/);
            let wordIndex = 0;
    
            let currentWord = {
                wordText: '',
                boundingBox: null,
                characters: []
            };
    
            let lastChar = null;
    
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const isLastChar = i === characters.length - 1 || !isCharInLine(characters[i + 1], line);
    
                if (isCharInLine(char, line)) {
                    // Add the character to the current word
                    currentWord.wordText += char.c;
                    currentWord.characters.push(char);
    
                    // Update bounding box
                    if (currentWord.boundingBox === null) {
                        currentWord.boundingBox = {
                            height: line.boundingBox.height,
                            top: line.boundingBox.top,
                            left: char.left,
                            width: char.width
                        };
                    } else {
                        const charRight = char.left + char.width;
                        const currentWordRight = currentWord.boundingBox.left + currentWord.boundingBox.width;
                        if (charRight > currentWordRight) {
                            currentWord.boundingBox.width = charRight - currentWord.boundingBox.left;
                        }
                    }
    
                    // Check if the currentWord matches the word from lineText
                    if (currentWord.wordText === wordsFromLineText[wordIndex]) {
                        lineStructure.words.push(currentWord);
                        wordIndex++; // Move to next word
    
                        // Reset the current word
                        currentWord = {
                            wordText: '',
                            boundingBox: null,
                            characters: []
                        };
                    }
    
                    lastChar = char;
                }
            }
    
            structure.push(lineStructure);
        }
    
        return structure;
    }
    
      function createHighlightAnnotation(boundingBox, type, pageIndex, instance) {
        const color = type === 'DELETE' ? PSPDFKit.Color.RED : PSPDFKit.Color.GREEN;
        const note = type === 'DELETE' ? `Deleted` : `Inserted`;
        pageIndex = 0;
        const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
          //note,
          boundingBox: new PSPDFKit.Geometry.Rect(boundingBox), // Use the boundingBox parameter here.
          pageIndex,
          color,
          opacity: 0.5,
          rects: PSPDFKit.Immutable.List.of(new PSPDFKit.Geometry.Rect(boundingBox))
        });
      

          instance.create(highlightAnnotation);
      }
      
      async function compareDocuments(doc1, doc2, instance1, instance2) {
        const pageIndex = 0;
      
        let i = 0, j = 0;
        while (i < doc1.length || j < doc2.length) {
          const line1 = doc1[i];
          const line2 = doc2[j];
      
          // Both lines are the same, proceed to the next line in both documents
          if (line1 && line2 && line1.lineText === line2.lineText) {
            i++;
            j++;
            continue;
          }
      
          // If we encounter different lines, we check for line shifts
          let lineShiftDetected = false;
      
          // Check if the current line in doc1 appears further down in doc2
          for (let k = j + 1; k < doc2.length; k++) {
            if (line1 && line1.lineText === doc2[k].lineText) {
              // Highlight lines in doc2[j:k] as 'INSERT'
              for (let l = j; l < k; l++) {
                createHighlightAnnotation(doc2[l].boundingBox, 'INSERT', pageIndex, instance2);
              }
              j = k;
              lineShiftDetected = true;
              break;
            }
          }
      
          // Check if the current line in doc2 appears further down in doc1
          if (!lineShiftDetected) {
            for (let k = i + 1; k < doc1.length; k++) {
              if (line2 && line2.lineText === doc1[k].lineText) {
                // Highlight lines in doc1[i:k] as 'DELETE'
                for (let l = i; l < k; l++) {
                  createHighlightAnnotation(doc1[l].boundingBox, 'DELETE', pageIndex, instance1);
                }
                i = k;
                lineShiftDetected = true;
                break;
              }
            }
          }
      
          // If no line shift is detected, we compare the words in the lines
          if (!lineShiftDetected) {
            if (line1 && line2) {
              compareWords(line1, line2, pageIndex, instance1, instance2);
            } else if (line1) {
              createHighlightAnnotation(line1.boundingBox, 'DELETE', pageIndex, instance1);
            } else if (line2) {
              createHighlightAnnotation(line2.boundingBox, 'INSERT', pageIndex, instance2);
            }
      
            i++;
            j++;
          }
        }
      }

      function compareWords(line1, line2, pageIndex, instance1, instance2) {
        let words1 = line1.words;
        let words2 = line2.words;
      
        let i = 0, j = 0;
        while (i < words1.length && j < words2.length) {
          let word1 = words1[i];
          let word2 = words2[j];
      
          if (word1.wordText === word2.wordText) {
            i++;
            j++;
            continue;
          }
      
          if (word1 && word2) {
            let differingCharacters = compareCharacters(word1, word2);
            if (differingCharacters.length <= 2) {
              // Highlight individual characters if only two or less are different
              for (const [char1, char2] of differingCharacters) {
                let boundingBoxChar1 = {
                  top: word1.boundingBox.top,
                  left: char1.left,
                  width: char1.width,
                  height: word1.boundingBox.height
                }
                let boundingBoxChar2 = {
                  top: word2.boundingBox.top,
                  left: char2.left,
                  width: char2.width,
                  height: word2.boundingBox.height
                }

                createHighlightAnnotation(boundingBoxChar1, 'DELETE', pageIndex, instance1);
                createHighlightAnnotation(boundingBoxChar2, 'INSERT', pageIndex, instance2);
              }
            } else {
              // Highlight entire word if more than two characters are different
              createHighlightAnnotation(word1.boundingBox, 'DELETE', pageIndex, instance1);
              createHighlightAnnotation(word2.boundingBox, 'INSERT', pageIndex, instance2);
            }
            i++;
            j++;
          }
        }
      }
      
      function compareCharacters(word1, word2) {
        let chars1 = word1.characters;
        let chars2 = word2.characters;
      
        let differingCharacters = [];
        let minLength = Math.min(chars1.length, chars2.length);
      
        for (let i = 0; i < minLength; i++) {
          let char1 = chars1[i];
          let char2 = chars2[i];
      
          if (char1.c !== char2.c) {
            differingCharacters.push([char1, char2]);
          }
        }
      
        // Handle any remaining characters if the lengths of the two words are different
        if (chars1.length !== chars2.length) {
          for (let i = minLength; i < Math.max(chars1.length, chars2.length); i++) {
            if (chars1[i]) {
              differingCharacters.push([chars1[i], null]);
            }
            if (chars2[i]) {
              differingCharacters.push([null, chars2[i]]);
            }
          }
        }
      
        return differingCharacters;
      }
      
      

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;

      // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

      console.log("Instance 1: ");
      console.log(glyphFormatted1);
      //console.log("Instance 2: ");
      //console.log(glyphFormatted2);

      console.log("text lines1");
      console.log(textLines1.toArray());

      const pageTextStructured1 = buildTextStructure(textLines1.toArray(), glyphFormatted1);
      const pageTextStructured2 = buildTextStructure(textLines2.toArray(), glyphFormatted2);
      console.log("pageTextStructured1");
      console.log(pageTextStructured1);
      console.log("pageTextStructured2");
      console.log(pageTextStructured2);

      compareDocuments(pageTextStructured1, pageTextStructured2, instance1, instance2);

      }

    }

    async function compareText(instance1, instance2) {


      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;
      
        while(index1 < textLines1.size && index2 < textLines2.size) {
          const line1 = textLines1.get(index1);
          const line2 = textLines2.get(index2);
      
          if(line1.contents === line2.contents) {
            index1++;
            index2++;
            continue;
          }
      
          const line1InText2 = textLines2.find(line => line.contents === line1.contents);
          const line2InText1 = textLines1.find(line => line.contents === line2.contents);
      
          if(line1InText2 && !line2InText1) {
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line added: "${line2.contents}"`,
              boundingBox: line2.boundingBox,
              pageIndex,
              color: PSPDFKit.Color.GREEN,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
            });
      
            console.log("line");
            console.log(highlightAnnotation);
            instance2.create(highlightAnnotation);
            lineShift += line2.boundingBox.height;
      
            index2++;
            continue;
          }
      
          if(line2InText1 && !line1InText2) {
            const newBoundingBox = new PSPDFKit.Geometry.Rect({
              top: line1.boundingBox.top, //- lineShift,
              left: line1.boundingBox.left,
              width: line1.boundingBox.width,
              height: line1.boundingBox.height
            });
      
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line removed: "${line1.contents}"`,
              boundingBox: newBoundingBox,
              pageIndex,
              color: PSPDFKit.Color.RED,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(newBoundingBox),
            });
      
            instance1.create(highlightAnnotation);
      
            index1++;
            continue;
          }
      
          if(line1InText2 && line2InText1) {
            index1++;
            index2++;
            continue;
          }
      
          const wordDiffs = Diff.diffWords(line1.contents, line2.contents);
          wordDiffs.forEach(wordDiff => {
            if (wordDiff.added || wordDiff.removed) {
              const note = wordDiff.added ? `Added: "${wordDiff.value}"` : `Deleted: "${wordDiff.value}"`;
      
              const newBoundingBox = wordDiff.removed
                ? new PSPDFKit.Geometry.Rect({
                  top: line1.boundingBox.top, //- lineShift,
                  left: line1.boundingBox.left,
                  width: line1.boundingBox.width,
                  height: line1.boundingBox.height
                  })
                : line2.boundingBox;

              const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
                note,
                boundingBox: newBoundingBox,
                pageIndex,
                color: wordDiff.added ? PSPDFKit.Color.GREEN : PSPDFKit.Color.RED,
                opacity: 0.5,
                rects: PSPDFKit.Immutable.List.of(newBoundingBox),
              });
      
              (wordDiff.added ? instance2 : instance1).create(highlightAnnotation);
            }
          });
      
          index1++;
          index2++;
        }
      
        while(index1 < textLines1.size) {
          const line1 = textLines1.get(index1);
      
          const newBoundingBox = new PSPDFKit.Geometry.Rect({
            ...line1.boundingBox,
            top: line1.boundingBox.top - lineShift,
          });
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line removed: "${line1.contents}"`,
            boundingBox: newBoundingBox,
            pageIndex,
            color: PSPDFKit.Color.RED,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(newBoundingBox),
          });
      
          instance1.create(highlightAnnotation);
      
          index1++;
        }
      
        while(index2 < textLines2.size) {
          const line2 = textLines2.get(index2);
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line added: "${line2.contents}"`,
            boundingBox: line2.boundingBox,
            pageIndex,
            color: PSPDFKit.Color.GREEN,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
          });
      
          instance2.create(highlightAnnotation);
      
          index2++;
        }
      }
    }
    

    PSPDFKit.load({
      container: "#pspdfkitLeft",
      document: "PDF poem v1.pdf",
      toolbarItems: defaultItemsLeft,
      licenseKey: licenseKey
    })
    .then(async function(instance) {
      console.log("PSPDFKit Left loaded", instance);
      leftViewer = instance;

      // Add event listeners for the left viewer to sync its state to the right viewer
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateLeft);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
      instance.addEventListener("viewState.zoom.change", syncViewStateLeft);

      window.setTimeout(() => {
        if (leftViewer && rightViewer) {
          //compareText(leftViewer, rightViewer);
          //compareTextAI(leftViewer, rightViewer);
          //compareTextAI2(leftViewer, rightViewer);
          //compareText2(leftViewer, rightViewer);
          compareText3(leftViewer, rightViewer);
        }
      }, 250);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    PSPDFKit.load({
      container: "#pspdfkitRight",
      document: "PDF poem v3.pdf",
      toolbarItems: defaultItemsRight,
      licenseKey: licenseKey

    })
    .then(async function(instance) {
      console.log("PSPDFKit Right loaded", instance);
      rightViewer = instance;

      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateRight);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
      instance.addEventListener("viewState.zoom.change", syncViewStateRight);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    function syncViewStateLeft() {

      let scrollElementR = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementR.removeEventListener("scroll", syncViewStateRight);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: leftViewer.viewState.currentPageIndex,
        zoomLevel: leftViewer.viewState.zoom,
        scrollLeft: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = rightViewer.viewState;
      rightViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      rightViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementR.addEventListener("scroll", syncViewStateRight);
      }, 0);
    }

    function syncViewStateRight() {

      let scrollElementL = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementL.removeEventListener("scroll", syncViewStateLeft);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: rightViewer.viewState.currentPageIndex,
        zoomLevel: rightViewer.viewState.zoom,
        scrollLeft: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = leftViewer.viewState;
      leftViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      leftViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementL.addEventListener("scroll", syncViewStateLeft);
      }, 0);
      
    }
  </script>

 

</body>
</html>
