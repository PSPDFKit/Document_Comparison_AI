
<html>
<head>
  <title>PSPDFKit Sync Scrolling</title>
</head>
<style>
  #viewer-container {
    display: flex;
    height: 100vh;
  }

  #viewer-container > div {
    width: 50%;
    height: 100%;
  }
</style>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

  <script src="./assets/pspdfkit.js"></script>
  <div id="viewer-container">
    <div id="pspdfkitLeft"></div>
    <div id="pspdfkitRight"></div>
  </div>


  <script>

    let licenseKey = 'vCR5dwIXsXHZsHQoufWEefkm8URHmt9zBymfQ5rWYpggjx_xYADpAXOHYxcdt_PbwurRb_c52uN5BrbRl0ta5wnVrcTnfSM4jASkm6QuPPiuhEI0xdglf_s-V-4aFMCK9u9XT0vJ3XPU4zyiMdem6Wd5sNvUEfP_fWPsbm1DnRMAJJl3vmXshBTlGtjlJYXwNn69OkOq6K9q7qGFHIx95iCXSQLSjRfpyEtWr0wjwLlUykC7tIt9qX8oGO-STn6hplnJzRWRFs_EdP4-YqzcLMaaY-GMKnOUSU5wrThJ7Bb6LJEWBTRX2XraeB6UFqM0rwMqcso8CnoDq1l3Qn_aNZS_6wmcj3K1azVL8NuMyBmu87nwzwlegvXjSqWIXHptd_FUqXX3Npze4CymDYNoRJuJy8s3bv1ikBvXkMKwQR8d1ayy8fs9tzcRyWamyzfzsCNjv1duLSGIkluTxIZMeYU2hd3nsFsFY7Bnot2MLGZI2udJ7iIFTx3QBS_zRFdQjJ_FLl9viOFVtjG_Rklfzqvn2675leoU7de7DBUOnUWQk8oZRUAvMmber1GzORnKeE1M37Wd5YxS20tQYrjRNr0BdaTOMEUshCyCI1EEjWrCy_zdlng2l2jZtrlYZkNsEwiGz8Cvn9UtmgVHg0UQPfzDYB8tk7Hv51rh5RR9xEllaFZMc82py7G_GjSHIRLyKJWiD_eaHbWxPEnzZszNhmqpA6Jx4Y-jVAPE-bub3LG6dd5nfzCHlbMOJTiNPHrSayPmX3QRTV14MpDcyRu8uZGhalXvx3IYcMPx_SLEXattbzdcT6OWH6nFmmrztq63pJ2IgnfDbeZ0XlarWKu0SYEMAq8fBl41tFFVYdztD6PU2qULlY3SyTQyL_FnQxw4oSgFTBXeyr80Mlj03FZf710WxYF1-JuWUQq4GlOlknuXqmVdjgCF4R__lKm0IPr0xCvTq4r5f9t7zXP3LT12QcQ5QtRXPi6By11pZMkTlKGbfzRbDuf2ksVAMhOSuPmYf3C-xZBdPGvm6r95ltSFxIdYNILrwJ2IjYs2RW3JxDWFpwK4MYpEiADzQP3SiKBgqKncfTcInoFmd5kM8mFddavDbw4uoaNLIUaSXphq_qgucHk5LQP7sHFjzfqVVWxYR_U6_NUZyvpUn-1Wv6YO9K5JzeR-lnCTxOxPIE-iA01qDhj2lZ-sJYy_zK0D19uPk9b8agtDudqWlQPebCtc6cHpfe3Wq16rlwiFheL4pVI=';

    let leftViewer, rightViewer;
    let defaultItemsLeft = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsLeft.pop();
    
    let defaultItemsRight = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsRight.pop();

    const uploadLeft = {
      type: "custom",
      id: "UploadLeft",
      title: "Upload Left Document",
      onPress: (event) => {
        if(leftViewer){
            // Create a new file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';

            // Listen for changes to the file input element
            fileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];

              // Unload the old document
              PSPDFKit.unload("#pspdfkitLeft");

              // Read the file
              const reader = new FileReader();
              reader.onload = async (event) => {
                // Load the new document
                leftViewer = await PSPDFKit.load({
                  container: "#pspdfkitLeft",
                  document: event.target.result,
                  toolbarItems: defaultItemsLeft,
                  licenseKey: licenseKey
                });

                // Delete all annotations in the other viewer
                // and compare the documents again.
                const totalPageCount = rightViewer.totalPageCount;
                for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                  const annotations = await rightViewer.getAnnotations(pageIndex);
                  rightViewer.delete(annotations);
                }
                
                // Add event listeners for the left viewer to sync its state to the right viewer
                let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
                scrollElement.addEventListener("scroll", syncViewStateLeft);

                // TODO: Needed when viewer is in single page mode
                //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
                leftViewer.addEventListener("viewState.zoom.change", syncViewStateLeft);

                compareText(leftViewer, rightViewer);
              };
              reader.readAsArrayBuffer(file);
            });

            // Open the file selector
            fileInput.click();
          }
      }
    };

    const uploadRight = {
      type: "custom",
      id: "UploadRight",
      title: "Upload Right Document",
      onPress: (event) => {
        if(rightViewer){
          // Create a new file input element
          const fileInput = document.createElement('input');
          fileInput.type = 'file';

          // Listen for changes to the file input element
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            // Unload the old document
            PSPDFKit.unload("#pspdfkitRight");

            // Read the file
            const reader = new FileReader();
            reader.onload = async (event) => {
              // Load the new document
              rightViewer = await PSPDFKit.load({
                container: "#pspdfkitRight",
                document: event.target.result,
                toolbarItems: defaultItemsRight,
                licenseKey: licenseKey
              });
              // Delete all annotations in the other viewer
              // and compare the documents again.
              const totalPageCount = leftViewer.totalPageCount;
              for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                const annotations = await leftViewer.getAnnotations(pageIndex);
                leftViewer.delete(annotations);
              }

              let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
              scrollElement.addEventListener("scroll", syncViewStateRight);
        
              // TODO: Needed when viewer is in single page mode
              //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
              rightViewer.addEventListener("viewState.zoom.change", syncViewStateRight);

              compareText(leftViewer, rightViewer);
            };
            reader.readAsArrayBuffer(file);
          });

          // Open the file selector
          fileInput.click();
        }
      }
    };

    defaultItemsLeft.push(uploadLeft);
    defaultItemsRight.push(uploadRight);

    function getFormattedGlyps(glyphs){

      function truncateNumbers(obj) {
        if (typeof obj === "number") {
          return parseFloat(obj.toFixed(0));
        } else if (typeof obj === "object" && obj !== null) {
          if (Array.isArray(obj)) {
            return obj.map(item => truncateNumbers(item));
          } else {
            const newObj = {};
            for (const key in obj) {
              newObj[key] = truncateNumbers(obj[key]);
            }
            return newObj;
          }
        }
        return obj;
      }
    
      // Assuming you have the flattened array
      const flattenedArray = glyphs.toArray();
    
      // Truncate numbers to two decimal points
      const truncatedArray = truncateNumbers(flattenedArray);
    
      // Convert the truncated array to a JSON string
      const jsonString = JSON.stringify(truncatedArray);
    
      // Log or use the JSON string as needed
      //console.log(jsonString);
    
      const optimizedJson = truncatedArray.map(item => {
        const { c, rect } = item;
        return { c, rect };
      });
    
      //console.log(JSON.stringify(optimizedJson, null, 2));
    
      // Create the formatted string
      let result = '';
      for (const item of optimizedJson) {
        const char = item.c;
        const left = truncateNumbers(item.rect.toJS().left);
        const top = truncateNumbers(item.rect.toJS().top);
        const width = truncateNumbers(item.rect.toJS().width);
        const height = truncateNumbers(item.rect.toJS().height);
    
        //result += `${char},${left},${top};`;
        // Check for newline or carriage return and replace with their names
        if (char === '\n') {
          result += `\n,${left},${top},${width},${height};`;
        } else if (char === '\r') {
          result += `\r,${left},${top},${width},${height};`;
        } else {
          result += `${char},${left},${top},${width},${height};`;
        }
      }
    
      // Remove the trailing semicolon
      result = result.slice(0, -1);
      return result;
    }

    async function compareTextAI(instance1, instance2) {
    
      // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

     // console.log("Instance 1: " + glyphFormatted1);
     //console.log("Instance 2: " + glyphFormatted2);

     const instructions = "your job is to parse two CSVs and compare them, they have the following format: <character>,<top position>,<left position>,<width>,<height> put the words and sentences based on the character together, the characters are in reading order. for example this P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10; translates to 'PDFs' after parsing both CSVs, compare the text of both CSVs and tell me if there are differences. your output should be in teh format of pspdfkit web highlight annotations. i want to create as few highlight annotations as possible to show all changes in the document. remember that th format for pspdfkit highlight annotations is as follows: {pageIndex: 0,rects: boundingBoxes,boundingBox: PSPDFKit.Geometry.Rect.union(boundingBoxes)} please group highlight annotations for neighbouring changed characters together into one as long as they are in the same word, don't list them as seperate rects in an array, but actually calculate one new rect. here is an example annotation  { pageIndex: 0, color : new PSPDFKit.Color({ r: 0, g: 255, b: 255 }), boundingBox: new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 }), rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 })]) }); your output should be strictly a json object with array element for each highlight annotation containing only the left, bottom, right, top, width and height property for each annotation only, without new lines \n or any other text, for example: { 'left': 74, 'bottom': 92, 'right': 112, 'top': 79, 'width': 38, 'height': 13 } start the annotation json with this keyword: 'annot:'" ;
     const userContent = "CSV1: P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;i,133,78,2,13;t,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;CSV2: P,74,79,8,13;B,84,79,10,13;A,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;x,133,78,2,13;g,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;";


      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer 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'
        },
        body: JSON.stringify({
          "model": "gpt-4",
          "temperature": 0,
          "messages": [
          {
            "role": "system",
            "content": instructions,
          },
            {
              "role": "user",
              "content": "CSV1: " + glyphFormatted1 + " CSV2: " + glyphFormatted2,
              //"content": userContent,
            }
          ]
        })
      })
      .then(async response => {
        let resp = await response.json();
        console.log(resp);
        let message = resp["choices"][0]["message"]["content"];
        console.log(message);

        // Extract the JSON part from the string
        let jsonPart = message.split("annot:")[1];
        jsonPart = jsonPart.replace(/'/g, '"');
        console.log("json part: ");
        console.log(jsonPart);

        const regex = /annot: {.*?}(?=\n|$)/g;
        const annotations = [];

        let match;
        while ((match = regex.exec(message)) !== null) {
            // Remove the "annot: " prefix and parse the JSON
            const jsonPart = match[0].replace("annot: ", "");
            try {
                const parsed = JSON.parse(jsonPart.replace(/'/g, "\"")); // Replacing single quotes with double quotes
                annotations.push(parsed);
            } catch (err) {
                console.error("Failed to parse JSON", err);
            }
        }

        console.log(annotations);

        // Parse the JSON part to a JavaScript object
        //let jsonArray = JSON.parse(jsonPart);

        if (!Array.isArray(annotations)) {
          annotations = [annotations];
      }

        // Loop through each JSON element and create a new HighlightAnnotation
        annotations.forEach(rect => {
          let annotation = new PSPDFKit.Annotations.HighlightAnnotation({
            pageIndex: 0,
            color: new PSPDFKit.Color({ r: 0, g: 255, b: 255 }),
            boundingBox: new PSPDFKit.Geometry.Rect({
              left: rect.left,
              bottom: rect.bottom,
              right: rect.right,
              top: rect.top,
              width: rect.width,
              height: rect.height
            }),
            rects: new PSPDFKit.Immutable.List([
              new PSPDFKit.Geometry.Rect({
                left: rect.left,
                bottom: rect.bottom,
                right: rect.right,
                top: rect.top,
                width: rect.width,
                height: rect.height
              })
            ])
          });
          // Use your PSPDFKit instance to create the annotation
          // Replace 'instance1' with your actual instance name
          instance1.create(annotation)
            .then(() => {
              console.log("Annotation created");
            })
            .catch(err => {
              console.error("Error creating annotation:", err);
            });
        });


        // Now `annotations` is an array of objects that you can import into PSPDFKit
        //console.log("creating this annot");
        //console.log(annotations);
        

        //wait instance1.create(annotations);
        //console.log("annot created");
      })
      .then(data => console.log(data))
      .catch((error) => console.error('Error:', error));
      
      /*let annotation = new PSPDFKit.Annotations.HighlightAnnotation({
        pageIndex: 0,  
        color : new PSPDFKit.Color({ r: 0, g: 255, b: 255 }),
        boundingBox: new PSPDFKit.Geometry.Rect({
          left: 82, 
          bottom: 92, 
          right: 101, 
          top: 79,
        width: 17,
      height: 13 }),
        rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({
          left: 82, 
          bottom: 92, 
          right: 101, 
          top: 79,
        width: 17,
      height: 13 })])
      });*/
      //instance1.create(annotation);
      //console.log("annot created");


    }

    async function compareText(instance1, instance2) {


      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;
      
        while(index1 < textLines1.size && index2 < textLines2.size) {
          const line1 = textLines1.get(index1);
          const line2 = textLines2.get(index2);
      
          if(line1.contents === line2.contents) {
            index1++;
            index2++;
            continue;
          }
      
          const line1InText2 = textLines2.find(line => line.contents === line1.contents);
          const line2InText1 = textLines1.find(line => line.contents === line2.contents);
      
          if(line1InText2 && !line2InText1) {
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line added: "${line2.contents}"`,
              boundingBox: line2.boundingBox,
              pageIndex,
              color: PSPDFKit.Color.GREEN,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
            });
      
            console.log("line");
            console.log(highlightAnnotation);
            instance2.create(highlightAnnotation);
            lineShift += line2.boundingBox.height;
      
            index2++;
            continue;
          }
      
          if(line2InText1 && !line1InText2) {
            const newBoundingBox = new PSPDFKit.Geometry.Rect({
              top: line1.boundingBox.top, //- lineShift,
              left: line1.boundingBox.left,
              width: line1.boundingBox.width,
              height: line1.boundingBox.height
            });
      
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line removed: "${line1.contents}"`,
              boundingBox: newBoundingBox,
              pageIndex,
              color: PSPDFKit.Color.RED,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(newBoundingBox),
            });
      
            instance1.create(highlightAnnotation);
      
            index1++;
            continue;
          }
      
          if(line1InText2 && line2InText1) {
            index1++;
            index2++;
            continue;
          }
      
          const wordDiffs = Diff.diffWords(line1.contents, line2.contents);
          wordDiffs.forEach(wordDiff => {
            if (wordDiff.added || wordDiff.removed) {
              const note = wordDiff.added ? `Added: "${wordDiff.value}"` : `Deleted: "${wordDiff.value}"`;
      
              const newBoundingBox = wordDiff.removed
                ? new PSPDFKit.Geometry.Rect({
                  top: line1.boundingBox.top, //- lineShift,
                  left: line1.boundingBox.left,
                  width: line1.boundingBox.width,
                  height: line1.boundingBox.height
                  })
                : line2.boundingBox;

              const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
                note,
                boundingBox: newBoundingBox,
                pageIndex,
                color: wordDiff.added ? PSPDFKit.Color.GREEN : PSPDFKit.Color.RED,
                opacity: 0.5,
                rects: PSPDFKit.Immutable.List.of(newBoundingBox),
              });
      
              (wordDiff.added ? instance2 : instance1).create(highlightAnnotation);
            }
          });
      
          index1++;
          index2++;
        }
      
        while(index1 < textLines1.size) {
          const line1 = textLines1.get(index1);
      
          const newBoundingBox = new PSPDFKit.Geometry.Rect({
            ...line1.boundingBox,
            top: line1.boundingBox.top - lineShift,
          });
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line removed: "${line1.contents}"`,
            boundingBox: newBoundingBox,
            pageIndex,
            color: PSPDFKit.Color.RED,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(newBoundingBox),
          });
      
          instance1.create(highlightAnnotation);
      
          index1++;
        }
      
        while(index2 < textLines2.size) {
          const line2 = textLines2.get(index2);
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line added: "${line2.contents}"`,
            boundingBox: line2.boundingBox,
            pageIndex,
            color: PSPDFKit.Color.GREEN,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
          });
      
          instance2.create(highlightAnnotation);
      
          index2++;
        }
      }
    }
    

    PSPDFKit.load({
      container: "#pspdfkitLeft",
      document: "PDF-single-line-v1.pdf",
      toolbarItems: defaultItemsLeft,
      licenseKey: licenseKey
    })
    .then(async function(instance) {
      console.log("PSPDFKit Left loaded", instance);
      leftViewer = instance;

      // Add event listeners for the left viewer to sync its state to the right viewer
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateLeft);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
      instance.addEventListener("viewState.zoom.change", syncViewStateLeft);

      window.setTimeout(() => {
        if (leftViewer && rightViewer) {
          //compareText(leftViewer, rightViewer);
          compareTextAI(leftViewer, rightViewer);
        }
      }, 250);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    PSPDFKit.load({
      container: "#pspdfkitRight",
      document: "PDF-single-line-v2.pdf",
      toolbarItems: defaultItemsRight,
      licenseKey: licenseKey

    })
    .then(async function(instance) {
      console.log("PSPDFKit Right loaded", instance);
      rightViewer = instance;

      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateRight);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
      instance.addEventListener("viewState.zoom.change", syncViewStateRight);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    function syncViewStateLeft() {

      let scrollElementR = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementR.removeEventListener("scroll", syncViewStateRight);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: leftViewer.viewState.currentPageIndex,
        zoomLevel: leftViewer.viewState.zoom,
        scrollLeft: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = rightViewer.viewState;
      rightViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      rightViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementR.addEventListener("scroll", syncViewStateRight);
      }, 0);
    }

    function syncViewStateRight() {

      let scrollElementL = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementL.removeEventListener("scroll", syncViewStateLeft);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: rightViewer.viewState.currentPageIndex,
        zoomLevel: rightViewer.viewState.zoom,
        scrollLeft: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = leftViewer.viewState;
      leftViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      leftViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementL.addEventListener("scroll", syncViewStateLeft);
      }, 0);
      
    }
  </script>

 

</body>
</html>
