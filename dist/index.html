
<html>
<head>
  <title>PSPDFKit Sync Scrolling</title>
</head>
<style>
  #viewer-container {
    display: flex;
    height: 100vh;
  }

  #viewer-container > div {
    width: 50%;
    height: 100%;
  }
</style>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

  <script src="./assets/pspdfkit.js"></script>
  <div id="viewer-container">
    <div id="pspdfkitLeft"></div>
    <div id="pspdfkitRight"></div>
  </div>


  <script>

    let licenseKey = 'vCR5dwIXsXHZsHQoufWEefkm8URHmt9zBymfQ5rWYpggjx_xYADpAXOHYxcdt_PbwurRb_c52uN5BrbRl0ta5wnVrcTnfSM4jASkm6QuPPiuhEI0xdglf_s-V-4aFMCK9u9XT0vJ3XPU4zyiMdem6Wd5sNvUEfP_fWPsbm1DnRMAJJl3vmXshBTlGtjlJYXwNn69OkOq6K9q7qGFHIx95iCXSQLSjRfpyEtWr0wjwLlUykC7tIt9qX8oGO-STn6hplnJzRWRFs_EdP4-YqzcLMaaY-GMKnOUSU5wrThJ7Bb6LJEWBTRX2XraeB6UFqM0rwMqcso8CnoDq1l3Qn_aNZS_6wmcj3K1azVL8NuMyBmu87nwzwlegvXjSqWIXHptd_FUqXX3Npze4CymDYNoRJuJy8s3bv1ikBvXkMKwQR8d1ayy8fs9tzcRyWamyzfzsCNjv1duLSGIkluTxIZMeYU2hd3nsFsFY7Bnot2MLGZI2udJ7iIFTx3QBS_zRFdQjJ_FLl9viOFVtjG_Rklfzqvn2675leoU7de7DBUOnUWQk8oZRUAvMmber1GzORnKeE1M37Wd5YxS20tQYrjRNr0BdaTOMEUshCyCI1EEjWrCy_zdlng2l2jZtrlYZkNsEwiGz8Cvn9UtmgVHg0UQPfzDYB8tk7Hv51rh5RR9xEllaFZMc82py7G_GjSHIRLyKJWiD_eaHbWxPEnzZszNhmqpA6Jx4Y-jVAPE-bub3LG6dd5nfzCHlbMOJTiNPHrSayPmX3QRTV14MpDcyRu8uZGhalXvx3IYcMPx_SLEXattbzdcT6OWH6nFmmrztq63pJ2IgnfDbeZ0XlarWKu0SYEMAq8fBl41tFFVYdztD6PU2qULlY3SyTQyL_FnQxw4oSgFTBXeyr80Mlj03FZf710WxYF1-JuWUQq4GlOlknuXqmVdjgCF4R__lKm0IPr0xCvTq4r5f9t7zXP3LT12QcQ5QtRXPi6By11pZMkTlKGbfzRbDuf2ksVAMhOSuPmYf3C-xZBdPGvm6r95ltSFxIdYNILrwJ2IjYs2RW3JxDWFpwK4MYpEiADzQP3SiKBgqKncfTcInoFmd5kM8mFddavDbw4uoaNLIUaSXphq_qgucHk5LQP7sHFjzfqVVWxYR_U6_NUZyvpUn-1Wv6YO9K5JzeR-lnCTxOxPIE-iA01qDhj2lZ-sJYy_zK0D19uPk9b8agtDudqWlQPebCtc6cHpfe3Wq16rlwiFheL4pVI=';

    let leftViewer, rightViewer;
    let defaultItemsLeft = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsLeft.pop();
    
    let defaultItemsRight = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsRight.pop();

    const uploadLeft = {
      type: "custom",
      id: "UploadLeft",
      title: "Upload Left Document",
      onPress: (event) => {
        if(leftViewer){
            // Create a new file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';

            // Listen for changes to the file input element
            fileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];

              // Unload the old document
              PSPDFKit.unload("#pspdfkitLeft");

              // Read the file
              const reader = new FileReader();
              reader.onload = async (event) => {
                // Load the new document
                leftViewer = await PSPDFKit.load({
                  container: "#pspdfkitLeft",
                  document: event.target.result,
                  toolbarItems: defaultItemsLeft,
                  licenseKey: licenseKey
                });

                // Delete all annotations in the other viewer
                // and compare the documents again.
                const totalPageCount = rightViewer.totalPageCount;
                for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                  const annotations = await rightViewer.getAnnotations(pageIndex);
                  rightViewer.delete(annotations);
                }
                
                // Add event listeners for the left viewer to sync its state to the right viewer
                let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
                scrollElement.addEventListener("scroll", syncViewStateLeft);

                // TODO: Needed when viewer is in single page mode
                //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
                leftViewer.addEventListener("viewState.zoom.change", syncViewStateLeft);

                compareText(leftViewer, rightViewer);
              };
              reader.readAsArrayBuffer(file);
            });

            // Open the file selector
            fileInput.click();
          }
      }
    };

    const uploadRight = {
      type: "custom",
      id: "UploadRight",
      title: "Upload Right Document",
      onPress: (event) => {
        if(rightViewer){
          // Create a new file input element
          const fileInput = document.createElement('input');
          fileInput.type = 'file';

          // Listen for changes to the file input element
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            // Unload the old document
            PSPDFKit.unload("#pspdfkitRight");

            // Read the file
            const reader = new FileReader();
            reader.onload = async (event) => {
              // Load the new document
              rightViewer = await PSPDFKit.load({
                container: "#pspdfkitRight",
                document: event.target.result,
                toolbarItems: defaultItemsRight,
                licenseKey: licenseKey
              });
              // Delete all annotations in the other viewer
              // and compare the documents again.
              const totalPageCount = leftViewer.totalPageCount;
              for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                const annotations = await leftViewer.getAnnotations(pageIndex);
                leftViewer.delete(annotations);
              }

              let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
              scrollElement.addEventListener("scroll", syncViewStateRight);
        
              // TODO: Needed when viewer is in single page mode
              //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
              rightViewer.addEventListener("viewState.zoom.change", syncViewStateRight);

              compareText(leftViewer, rightViewer);
            };
            reader.readAsArrayBuffer(file);
          });

          // Open the file selector
          fileInput.click();
        }
      }
    };

    defaultItemsLeft.push(uploadLeft);
    defaultItemsRight.push(uploadRight);

    function getFormattedGlyps(glyphs){

      function truncateNumbers(obj) {
        if (typeof obj === "number") {
          return parseFloat(obj.toFixed(1));
        } else if (typeof obj === "object" && obj !== null) {
          if (Array.isArray(obj)) {
            return obj.map(item => truncateNumbers(item));
          } else {
            const newObj = {};
            for (const key in obj) {
              newObj[key] = truncateNumbers(obj[key]);
            }
            return newObj;
          }
        }
        return obj;
      }
    
      // Assuming you have the flattened array
      const flattenedArray = glyphs.toArray();
    
      // Truncate numbers to two decimal points
      const truncatedArray = truncateNumbers(flattenedArray);
    
      // Convert the truncated array to a JSON string
      const jsonString = JSON.stringify(truncatedArray);
    
      // Log or use the JSON string as needed
      //console.log(jsonString);
    
      const optimizedJson = truncatedArray.map(item => {
        const { c, rect } = item;
        return { c, rect };
      });
    
      //console.log(JSON.stringify(optimizedJson, null, 2));
    
      // Create the formatted string
      let result = '';
      for (const item of optimizedJson) {
        const char = item.c;
        const left = truncateNumbers(item.rect.toJS().left);
        const top = truncateNumbers(item.rect.toJS().top);
    
        //result += `${char},${left},${top};`;
        // Check for newline or carriage return and replace with their names
        if (char === '\n') {
          result += `\n,${left},${top};`;
        } else if (char === '\r') {
          result += `\r,${left},${top};`;
        } else {
          result += `${char},${left},${top};`;
        }
      }
    
      // Remove the trailing semicolon
      result = result.slice(0, -1);
      return result;
    }

    async function compareTextAI(instance1, instance2) {
    
      // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

      console.log("Instance 1: " + glyphFormatted1);
      console.log("Instance 2: " + glyphFormatted2);
    }

    async function compareText(instance1, instance2) {


      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;
      
        while(index1 < textLines1.size && index2 < textLines2.size) {
          const line1 = textLines1.get(index1);
          const line2 = textLines2.get(index2);
      
          if(line1.contents === line2.contents) {
            index1++;
            index2++;
            continue;
          }
      
          const line1InText2 = textLines2.find(line => line.contents === line1.contents);
          const line2InText1 = textLines1.find(line => line.contents === line2.contents);
      
          if(line1InText2 && !line2InText1) {
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line added: "${line2.contents}"`,
              boundingBox: line2.boundingBox,
              pageIndex,
              color: PSPDFKit.Color.GREEN,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
            });
      
            instance2.create(highlightAnnotation);
            lineShift += line2.boundingBox.height;
      
            index2++;
            continue;
          }
      
          if(line2InText1 && !line1InText2) {
            const newBoundingBox = new PSPDFKit.Geometry.Rect({
              top: line1.boundingBox.top, //- lineShift,
              left: line1.boundingBox.left,
              width: line1.boundingBox.width,
              height: line1.boundingBox.height
            });
      
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line removed: "${line1.contents}"`,
              boundingBox: newBoundingBox,
              pageIndex,
              color: PSPDFKit.Color.RED,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(newBoundingBox),
            });
      
            instance1.create(highlightAnnotation);
      
            index1++;
            continue;
          }
      
          if(line1InText2 && line2InText1) {
            index1++;
            index2++;
            continue;
          }
      
          const wordDiffs = Diff.diffWords(line1.contents, line2.contents);
          wordDiffs.forEach(wordDiff => {
            if (wordDiff.added || wordDiff.removed) {
              const note = wordDiff.added ? `Added: "${wordDiff.value}"` : `Deleted: "${wordDiff.value}"`;
      
              const newBoundingBox = wordDiff.removed
                ? new PSPDFKit.Geometry.Rect({
                  top: line1.boundingBox.top, //- lineShift,
                  left: line1.boundingBox.left,
                  width: line1.boundingBox.width,
                  height: line1.boundingBox.height
                  })
                : line2.boundingBox;

              const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
                note,
                boundingBox: newBoundingBox,
                pageIndex,
                color: wordDiff.added ? PSPDFKit.Color.GREEN : PSPDFKit.Color.RED,
                opacity: 0.5,
                rects: PSPDFKit.Immutable.List.of(newBoundingBox),
              });
      
              (wordDiff.added ? instance2 : instance1).create(highlightAnnotation);
            }
          });
      
          index1++;
          index2++;
        }
      
        while(index1 < textLines1.size) {
          const line1 = textLines1.get(index1);
      
          const newBoundingBox = new PSPDFKit.Geometry.Rect({
            ...line1.boundingBox,
            top: line1.boundingBox.top - lineShift,
          });
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line removed: "${line1.contents}"`,
            boundingBox: newBoundingBox,
            pageIndex,
            color: PSPDFKit.Color.RED,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(newBoundingBox),
          });
      
          instance1.create(highlightAnnotation);
      
          index1++;
        }
      
        while(index2 < textLines2.size) {
          const line2 = textLines2.get(index2);
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line added: "${line2.contents}"`,
            boundingBox: line2.boundingBox,
            pageIndex,
            color: PSPDFKit.Color.GREEN,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
          });
      
          instance2.create(highlightAnnotation);
      
          index2++;
        }
      }
    }
    

    PSPDFKit.load({
      container: "#pspdfkitLeft",
      document: "PDF poem v1.pdf",
      toolbarItems: defaultItemsLeft,
      licenseKey: licenseKey
    })
    .then(async function(instance) {
      console.log("PSPDFKit Left loaded", instance);
      leftViewer = instance;

      // Add event listeners for the left viewer to sync its state to the right viewer
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateLeft);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
      instance.addEventListener("viewState.zoom.change", syncViewStateLeft);

      window.setTimeout(() => {
        if (leftViewer && rightViewer) {
          compareText(leftViewer, rightViewer);
          compareTextAI(leftViewer, rightViewer);
        }
      }, 250);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    PSPDFKit.load({
      container: "#pspdfkitRight",
      document: "PDF poem v3.pdf",
      toolbarItems: defaultItemsRight,
      licenseKey: licenseKey

    })
    .then(async function(instance) {
      console.log("PSPDFKit Right loaded", instance);
      rightViewer = instance;

      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateRight);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
      instance.addEventListener("viewState.zoom.change", syncViewStateRight);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    function syncViewStateLeft() {

      let scrollElementR = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementR.removeEventListener("scroll", syncViewStateRight);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: leftViewer.viewState.currentPageIndex,
        zoomLevel: leftViewer.viewState.zoom,
        scrollLeft: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = rightViewer.viewState;
      rightViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      rightViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementR.addEventListener("scroll", syncViewStateRight);
      }, 0);
    }

    function syncViewStateRight() {

      let scrollElementL = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementL.removeEventListener("scroll", syncViewStateLeft);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: rightViewer.viewState.currentPageIndex,
        zoomLevel: rightViewer.viewState.zoom,
        scrollLeft: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = leftViewer.viewState;
      leftViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      leftViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementL.addEventListener("scroll", syncViewStateLeft);
      }, 0);
      
    }
  </script>

 

</body>
</html>
