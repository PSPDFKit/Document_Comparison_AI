
<html>
<head>
  <title>PSPDFKit Sync Scrolling</title>
</head>
<style>
  #viewer-container {
    display: flex;
    height: 100vh;
  }

  #viewer-container > div {
    width: 50%;
    height: 100%;
  }
</style>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

  <script src="./assets/pspdfkit.js"></script>
  <div id="viewer-container">
    <div id="pspdfkitLeft"></div>
    <div id="pspdfkitRight"></div>
  </div>


  <script>

    let licenseKey = 'vCR5dwIXsXHZsHQoufWEefkm8URHmt9zBymfQ5rWYpggjx_xYADpAXOHYxcdt_PbwurRb_c52uN5BrbRl0ta5wnVrcTnfSM4jASkm6QuPPiuhEI0xdglf_s-V-4aFMCK9u9XT0vJ3XPU4zyiMdem6Wd5sNvUEfP_fWPsbm1DnRMAJJl3vmXshBTlGtjlJYXwNn69OkOq6K9q7qGFHIx95iCXSQLSjRfpyEtWr0wjwLlUykC7tIt9qX8oGO-STn6hplnJzRWRFs_EdP4-YqzcLMaaY-GMKnOUSU5wrThJ7Bb6LJEWBTRX2XraeB6UFqM0rwMqcso8CnoDq1l3Qn_aNZS_6wmcj3K1azVL8NuMyBmu87nwzwlegvXjSqWIXHptd_FUqXX3Npze4CymDYNoRJuJy8s3bv1ikBvXkMKwQR8d1ayy8fs9tzcRyWamyzfzsCNjv1duLSGIkluTxIZMeYU2hd3nsFsFY7Bnot2MLGZI2udJ7iIFTx3QBS_zRFdQjJ_FLl9viOFVtjG_Rklfzqvn2675leoU7de7DBUOnUWQk8oZRUAvMmber1GzORnKeE1M37Wd5YxS20tQYrjRNr0BdaTOMEUshCyCI1EEjWrCy_zdlng2l2jZtrlYZkNsEwiGz8Cvn9UtmgVHg0UQPfzDYB8tk7Hv51rh5RR9xEllaFZMc82py7G_GjSHIRLyKJWiD_eaHbWxPEnzZszNhmqpA6Jx4Y-jVAPE-bub3LG6dd5nfzCHlbMOJTiNPHrSayPmX3QRTV14MpDcyRu8uZGhalXvx3IYcMPx_SLEXattbzdcT6OWH6nFmmrztq63pJ2IgnfDbeZ0XlarWKu0SYEMAq8fBl41tFFVYdztD6PU2qULlY3SyTQyL_FnQxw4oSgFTBXeyr80Mlj03FZf710WxYF1-JuWUQq4GlOlknuXqmVdjgCF4R__lKm0IPr0xCvTq4r5f9t7zXP3LT12QcQ5QtRXPi6By11pZMkTlKGbfzRbDuf2ksVAMhOSuPmYf3C-xZBdPGvm6r95ltSFxIdYNILrwJ2IjYs2RW3JxDWFpwK4MYpEiADzQP3SiKBgqKncfTcInoFmd5kM8mFddavDbw4uoaNLIUaSXphq_qgucHk5LQP7sHFjzfqVVWxYR_U6_NUZyvpUn-1Wv6YO9K5JzeR-lnCTxOxPIE-iA01qDhj2lZ-sJYy_zK0D19uPk9b8agtDudqWlQPebCtc6cHpfe3Wq16rlwiFheL4pVI=';

    let leftViewer, rightViewer;
    let defaultItemsLeft = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsLeft.pop();
    
    let defaultItemsRight = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsRight.pop();

    const uploadLeft = {
      type: "custom",
      id: "UploadLeft",
      title: "Upload Left Document",
      onPress: (event) => {
        if(leftViewer){
            // Create a new file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';

            // Listen for changes to the file input element
            fileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];

              // Unload the old document
              PSPDFKit.unload("#pspdfkitLeft");

              // Read the file
              const reader = new FileReader();
              reader.onload = async (event) => {
                // Load the new document
                leftViewer = await PSPDFKit.load({
                  container: "#pspdfkitLeft",
                  document: event.target.result,
                  toolbarItems: defaultItemsLeft,
                  licenseKey: licenseKey
                });

                // Delete all annotations in the other viewer
                // and compare the documents again.
                const totalPageCount = rightViewer.totalPageCount;
                for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                  const annotations = await rightViewer.getAnnotations(pageIndex);
                  rightViewer.delete(annotations);
                }
                
                // Add event listeners for the left viewer to sync its state to the right viewer
                let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
                scrollElement.addEventListener("scroll", syncViewStateLeft);

                // TODO: Needed when viewer is in single page mode
                //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
                leftViewer.addEventListener("viewState.zoom.change", syncViewStateLeft);

                compareText(leftViewer, rightViewer);
              };
              reader.readAsArrayBuffer(file);
            });

            // Open the file selector
            fileInput.click();
          }
      }
    };

    const uploadRight = {
      type: "custom",
      id: "UploadRight",
      title: "Upload Right Document",
      onPress: (event) => {
        if(rightViewer){
          // Create a new file input element
          const fileInput = document.createElement('input');
          fileInput.type = 'file';

          // Listen for changes to the file input element
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            // Unload the old document
            PSPDFKit.unload("#pspdfkitRight");

            // Read the file
            const reader = new FileReader();
            reader.onload = async (event) => {
              // Load the new document
              rightViewer = await PSPDFKit.load({
                container: "#pspdfkitRight",
                document: event.target.result,
                toolbarItems: defaultItemsRight,
                licenseKey: licenseKey
              });
              // Delete all annotations in the other viewer
              // and compare the documents again.
              const totalPageCount = leftViewer.totalPageCount;
              for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                const annotations = await leftViewer.getAnnotations(pageIndex);
                leftViewer.delete(annotations);
              }

              let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
              scrollElement.addEventListener("scroll", syncViewStateRight);
        
              // TODO: Needed when viewer is in single page mode
              //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
              rightViewer.addEventListener("viewState.zoom.change", syncViewStateRight);

              compareText(leftViewer, rightViewer);
            };
            reader.readAsArrayBuffer(file);
          });

          // Open the file selector
          fileInput.click();
        }
      }
    };

    defaultItemsLeft.push(uploadLeft);
    defaultItemsRight.push(uploadRight);

    function getFormattedGlyps(glyphs){

      function truncateNumbers(obj) {
        if (typeof obj === "number") {
          return parseFloat(obj.toFixed(0));
        } else if (typeof obj === "object" && obj !== null) {
          if (Array.isArray(obj)) {
            return obj.map(item => truncateNumbers(item));
          } else {
            const newObj = {};
            for (const key in obj) {
              newObj[key] = truncateNumbers(obj[key]);
            }
            return newObj;
          }
        }
        return obj;
      }
    
      // Assuming you have the flattened array
      const flattenedArray = glyphs.toArray();
    
      // Truncate numbers to two decimal points
      const truncatedArray = truncateNumbers(flattenedArray);
    
      // Convert the truncated array to a JSON string
      const jsonString = JSON.stringify(truncatedArray);
    
      // Log or use the JSON string as needed
      //console.log(jsonString);
    
      const optimizedJson = truncatedArray.map(item => {
        const { c, rect } = item;
        return { c, rect };
      });
    
      //console.log(JSON.stringify(optimizedJson, null, 2));
    
      // Create the formatted string
      let result = '';
      for (const item of optimizedJson) {
        const char = item.c;
        const left = truncateNumbers(item.rect.toJS().left);
        const top = truncateNumbers(item.rect.toJS().top);
        const width = truncateNumbers(item.rect.toJS().width);
        const height = truncateNumbers(item.rect.toJS().height);
    
        //result += `${char},${left},${top};`;
        // Check for newline or carriage return and replace with their names
        if (char === '\n') {
          result += `\n,${left},${top},${width},${height};`;
        } else if (char === '\r') {
          result += `\r,${left},${top},${width},${height};`;
        } else {
          result += `${char},${left},${top},${width},${height};`;
        }
      }
    
      // Remove the trailing semicolon
      result = result.slice(0, -1);
      return result;
    }

    async function compareTextAI(instance1, instance2) {
    
      // Get glyphs for each instance with their position in CSV format
      let glyphs1 = await instance1.getPageGlyphs(0);
      let glyphFormatted1 = getFormattedGlyps(glyphs1);

      let glyphs2 = await instance2.getPageGlyphs(0);
      let glyphFormatted2 = getFormattedGlyps(glyphs2);

      console.log("Instance 1: " + glyphFormatted1);
     //console.log("Instance 2: " + glyphFormatted2);

            // The variable 'userContent' should contain the message from the user
      let userContent = `P,73.7,78.6;D,84,78.6;F,96.3,78.6;s,104.6,81.8;,,112.1,89; ,116.7,71.3;d,122.1,77.7;i,133,78.3;g,136.8,81.8;i,147,78.3;t,150.6,79.6;a,157.9,81.8;l,168.1,77.7; ,171.2,71.3;d,176.6,77.7;o,187.1,81.8;c,197.6,81.8;s,206,81.8; ,213,71.3;s,218.3,81.8;o,226.2,81.8; ,235.9,71.3;f,240.8,77.6;i,247.8,78.3;n,252.6,81.8;e,262.5,81.8;,,272,89;
        ,275.2,91.2;
        ,275.2,91.2;W,72.6,102.8;i,91.1,102.5;t,94.7,103.8;h,102.6,101.9; ,111.6,95.5;p,117.6,106;a,127.5,106;g,136.7,106;e,146.5,106;s,156.3,106; ,163.4,95.5;o,168.8,106;f,178.8,101.8; ,184.5,95.5;t,189.4,103.8;e,196.6,106;x,206.1,106.1;t,214.7,103.8; ,221.1,95.5;a,226.5,106;n,236.7,106;d,246.6,101.9; ,256.2,95.5;i,262,102.5;m,266.8,106;a,282.2,106;g,291.4,106;e,301.1,106;s,311,106; ,318,95.5;c,323.4,106;o,331.9,106;m,343,106;b,359,101.9;i,369.3,102.5;n,374.1,106;e,384,106;d,394,101.9;.,405,113.3;
        ,407.1,115.4;
        ,407.1,115.4;T,72.1,127.3;h,83.2,126.4;e,93.1,130.5;y,102.5,130.6; ,111.2,120;t,116.1,128.3;r,124,130.5;a,130.3,130.5;v,139.4,130.6;e,149,130.5;l,159.5,126.4; ,162.6,120;f,167.5,126.3;a,174.1,130.5;r,184.3,130.5; ,189.8,120;a,195.2,130.5;n,205.4,130.5;d,215.4,126.4; ,224.9,120;w,230,130.6;i,245,127;d,249.3,126.4;e,259.7,130.5;,,269.2,137.7;
        ,272.4,139.9;
        ,272.4,139.9;T,72.1,151.8;h,83.2,150.9;e,93.1,155;i,103.5,151.5;r,108.3,155; ,113.8,144.5;c,119.2,155;o,127.6,155;n,138.8,155;t,148.1,152.8;e,155.4,155;n,165.9,155;t,175.3,152.8; ,181.6,144.5;s,187,155;e,194.9,155;c,204.8,155;u,213.8,155.1;r,224.4,155;e,230.8,155; ,239.8,144.5;a,245.2,155;n,255.4,155;d,265.4,150.9; ,274.9,144.5;l,281,150.9;o,284.9,155;c,295.5,155;k,304.5,150.9;e,313,155;d,323,150.9; ,332.6,144.5;i,338.4,151.5;n,343.2,155;s,353,155;i,361.3,151.5;d,365.5,150.9;e,376,155;.,386.5,162.2;
        ,388.6,164.4;
        ,388.6,164.4;F,73.7,176.3;r,82.7,179.4;o,89,179.4;m,100.2,179.4; ,114.7,169;c,120.1,179.5;o,128.5,179.4;n,139.7,179.4;t,149,177.2;r,156.9,179.4;a,163.3,179.4;c,172.9,179.5;t,180.8,177.2;s,187.9,179.4; ,195,169;t,199.8,177.2;o,207.1,179.4; ,216.7,169;b,222.7,175.3;o,232.6,179.4;o,243.2,179.4;k,254.3,175.3;s,262.7,179.4;,,270.2,186.7; ,274.7,169;t,279.6,177.2;h,287.5,175.3;e,297.4,179.4;y,306.7,179.6; ,315.5,169;h,321.5,175.3;o,331.4,179.4;l,342.5,175.3;d,346.6,175.4; ,356.1,169;m,362.1,179.4;u,378.1,179.6;c,388,179.5;h,397.1,175.3; ,406.1,169;d,411.6,175.4;a,422,179.4;t,431,177.2;a,438.3,179.4;,,447.4,186.7;
        ,450.6,188.9;
        ,450.6,188.9;A,72.3,200.5; ,83.6,193.2;w,88.6,203.8;e,103.3,203.7;a,113.2,203.7;l,123.4,199.6;t,126.8,201.5;h,134.7,199.6; ,143.7,193.2;o,149.1,203.7;f,159.2,199.5; ,164.9,193.2;w,169.9,203.8;i,185,200.2;s,189.1,203.7;d,197,199.6;o,207.5,203.7;m,218.7,203.7;,,233.6,210.9; ,238.2,193.2;j,242.3,200.2;u,248.9,203.8;s,258.8,203.7;t,266.1,201.5; ,272.5,193.2;a,277.9,203.7; ,286.6,193.2;s,291.9,203.7;i,300.2,200.2;m,305,203.7;p,321,203.7;l,331.5,199.6;e,335.5,203.7; ,344.5,193.2;t,349.4,201.5;o,356.6,203.7;u,367.7,203.8;c,377.7,203.7;h,386.8,199.6; ,395.8,193.2;t,400.6,201.5;o,407.9,203.7; ,417.6,193.2;g,422.6,203.7;e,432.4,203.7;t,441.8,201.5; ,448.2,193.2;a,453.6,203.7;.,463.7,210.9;
        ,465.8,213.1;
        ,465.8,213.1;E,73.7,225;a,82.7,228.2;s,92.1,228.2;i,100.5,224.7;l,105.2,224.1;y,108.7,228.3; ,117.4,217.7;a,122.8,228.2;c,132.4,228.2;c,140.8,228.2;e,149.3,228.2;s,159.1,228.2;s,166.9,228.2;i,175.3,224.7;b,180,224.1;l,190.5,224.1;e,194.5,228.2;,,204,235.4; ,208.6,217.7;j,212.7,224.7;u,219.3,228.3;s,229.2,228.2;t,236.5,226; ,242.9,217.7;a,248.3,228.2; ,257,217.7;c,262.4,228.2;l,271.5,224.1;i,275.9,224.7;c,280,228.2;k,289.1,224.1;,,297.1,235.4;
        ,300.3,237.6;
        ,300.3,237.6;T,72.1,249.5;h,83.2,248.5;e,93.1,252.6;i,103.5,249.2;r,108.3,252.6; ,113.8,242.2;v,118.6,252.8;e,128.2,252.6;r,138.8,252.6;s,145,252.6;a,153,252.6;t,162,250.4;i,169.6,249.2;l,174.4,248.5;i,178.8,249.2;t,182.4,250.4;y,189.1,252.8;,,198.3,259.9; ,202.8,242.2;a,208.3,252.6; ,217,242.2;c,222.4,252.7;l,231.4,248.5;e,235.4,252.6;v,244.8,252.8;e,254.4,252.6;r,265,252.6; ,270.4,242.2;t,275.3,250.4;r,283.1,252.6;i,289.9,249.2;c,294.1,252.7;k,303.1,248.5;.,312.2,259.9;
        ,314.3,262.1;
        ,314.3,262.1;N,73.7,274;o,85.8,277.1; ,95.4,266.6;m,101.5,277.1;a,116.8,277.1;t,125.9,274.9;t,132.5,274.9;e,139.8,277.1;r,150.4,277.1; ,155.8,266.6;t,160.7,274.9;h,168.6,273;e,178.5,277.1; ,187.5,266.6;p,193.5,277.1;l,204,273;a,208,277.1;t,217,274.9;f,223.7,272.9;o,230.4,277.1;r,241.5,277.1;m,248.5,277.1;,,263.4,284.4; ,268,266.6;t,272.8,274.9;h,280.7,273;e,290.6,277.1;y,300,277.3; ,308.7,266.6;r,314.7,277.1;e,321.1,277.1;m,331.6,277.1;a,347,277.1;i,357,273.7;n,361.7,277.1; ,370.8,266.6;t,375.6,274.9;h,383.5,273;e,393.4,277.1; ,402.4,266.6;s,407.7,277.1;a,415.7,277.1;m,425.8,277.1;e,441.2,277.1;,,450.7,284.4;
        ,453.9,286.6;
        ,453.9,286.6;T,72.1,298.2;h,83.2,297.3;e,93.1,301.4;i,103.5,297.9;r,108.3,301.4; ,113.8,290.9;f,118.6,297.2;o,125.3,301.4;r,136.4,301.4;m,143.4,301.4;a,158.8,301.4;t,167.8,299.2; ,174.2,290.9;u,180.1,301.5;n,190.7,301.4;i,201,297.9;v,204.6,301.5;e,214.2,301.4;r,224.8,301.4;s,231.1,301.4;a,239,301.4;l,249.2,297.3;,,252.7,308.6; ,257.2,290.9;t,262.1,299.2;h,270,297.3;e,279.9,301.4;i,290.2,297.9;r,295,301.4; ,300.5,290.9;f,305.4,297.2;a,312,301.4;m,322.2,301.4;e,337.6,301.4; ,346.6,290.9;r,352.6,301.4;e,359,301.4;m,369.6,301.4;a,385,301.4;i,394.9,297.9;n,399.7,301.4;s,409.5,301.4; ,416.5,290.9;i,422.4,297.9;n,427.2,301.4; ,436.2,290.9;t,441,299.2;h,448.9,297.3;e,458.8,301.4';
        ,466.9,310.8;
        ,466.9,310.8;f,72.4,321.7;r,79.6,325.8;a,86,325.8;m,96.2,325.8;e,111.6,325.8;.,122.1,333.1;
        ,124.2,335.3;
        ,124.2,335.3;P,73.7,347.2;D,84,347.2;F,96.3,347.2;s,104.6,350.3;,,112.1,357.6; ,116.7,339.8;t,121.5,348.1;h,129.4,346.2;e,139.3,350.3; ,148.3,339.8;f,153.2,346.1;u,160.4,350.5;t,169.8,348.1;u,177.6,350.5;r,188.2,350.3;e,194.6,350.3; ,203.6,339.8;o,209,350.3;f,219,346.1; ,224.8,339.8;p,230.8,350.3;a,240.7,350.3;p,250.9,350.3;e,260.8,350.3;r,271.4,350.3; ,276.8,339.8;a,282.2,350.3;n,292.4,350.3;d,302.4,346.3; ,311.9,339.8;i,317.8,346.9;n,322.5,350.3;k,333.1,346.2;,,341.1,357.6;
        ,344.3,359.8;
        ,344.3,359.8;F,73.7,371.4;o,82.1,374.6;r,93.2,374.6;e,99.6,374.6;v,109,374.7;e,118.6,374.6;r,129.1,374.6; ,134.6,364.1;c,140,374.6h,149.1,370.5;a,159,374.6;n,169.2,374.6;g,178.7,374.6;i,188.9,371.1;n,193.7,374.6;g,203.2,374.6; ,212.1,364.1;t,216.9,372.4;h,224.8,370.5;e,234.7,374.6; ,243.8,364.1;w,248.8,374.7;a,263.5,374.6;y,272.5,374.7; ,281.2,364.1;w,286.3,374.7;e,300.9,374.6; ,310,364.1;t,314.8,372.4;h,322.7,370.5;i,333,371.1;n,337.8,374.6;k,348.3,370.5;.,357.4,381.8`;

      /*fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer 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'
        },
        body: JSON.stringify({
          "model": "gpt-4-0613",
          "messages": [
          {
            "role": "system",
            "content": "your job is to parse CSVs, they have the following format: <character>,<top position>,<left position> ignore the top and left position for now and just put the words and sentences based on the character together, the characters are in reading order. for example this P,73.67,78.61;D,84.01,78.61;F,96.31,78.61;s,104.63,81.76;,,112.08,89.03; ,116.65,71.28;d,122.1,77.69;i,132.97,78.29;g,136.79,81.78;i,146.98,78.29;t,150.6,79.57;a,157.89,81.76;l,168.06,77.65; translates to 'PDFs digital' what does this text translate to? reply with the parsed sentences only."
        },
            {
              "role": "user",
              "content": userContent
            }
          ]
        })
      })
      .then(response => response.json())
      .then(data => console.log(data))
      .catch((error) => console.error('Error:', error));*/
      
      let annotation = new PSPDFKit.Annotations.HighlightAnnotation({
        pageIndex: 0,  
        color : new PSPDFKit.Color({ r: 0, g: 255, b: 255 }),
        boundingBox: new PSPDFKit.Geometry.Rect({
          left: 82, 
          bottom: 92, 
          right: 101, 
          top: 79,
        width: 17,
      height: 13 }),
        rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({
          left: 82, 
          bottom: 92, 
          right: 101, 
          top: 79,
        width: 17,
      height: 13 })])
      });
      instance1.create(annotation);
      console.log("annot created");


    }

    async function compareText(instance1, instance2) {


      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
        let index1 = 0, index2 = 0;
        let lineShift = 0;
      
        while(index1 < textLines1.size && index2 < textLines2.size) {
          const line1 = textLines1.get(index1);
          const line2 = textLines2.get(index2);
      
          if(line1.contents === line2.contents) {
            index1++;
            index2++;
            continue;
          }
      
          const line1InText2 = textLines2.find(line => line.contents === line1.contents);
          const line2InText1 = textLines1.find(line => line.contents === line2.contents);
      
          if(line1InText2 && !line2InText1) {
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line added: "${line2.contents}"`,
              boundingBox: line2.boundingBox,
              pageIndex,
              color: PSPDFKit.Color.GREEN,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
            });
      
            console.log("line");
            console.log(highlightAnnotation);
            instance2.create(highlightAnnotation);
            lineShift += line2.boundingBox.height;
      
            index2++;
            continue;
          }
      
          if(line2InText1 && !line1InText2) {
            const newBoundingBox = new PSPDFKit.Geometry.Rect({
              top: line1.boundingBox.top, //- lineShift,
              left: line1.boundingBox.left,
              width: line1.boundingBox.width,
              height: line1.boundingBox.height
            });
      
            const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
              note: `Line removed: "${line1.contents}"`,
              boundingBox: newBoundingBox,
              pageIndex,
              color: PSPDFKit.Color.RED,
              opacity: 0.5,
              rects: PSPDFKit.Immutable.List.of(newBoundingBox),
            });
      
            instance1.create(highlightAnnotation);
      
            index1++;
            continue;
          }
      
          if(line1InText2 && line2InText1) {
            index1++;
            index2++;
            continue;
          }
      
          const wordDiffs = Diff.diffWords(line1.contents, line2.contents);
          wordDiffs.forEach(wordDiff => {
            if (wordDiff.added || wordDiff.removed) {
              const note = wordDiff.added ? `Added: "${wordDiff.value}"` : `Deleted: "${wordDiff.value}"`;
      
              const newBoundingBox = wordDiff.removed
                ? new PSPDFKit.Geometry.Rect({
                  top: line1.boundingBox.top, //- lineShift,
                  left: line1.boundingBox.left,
                  width: line1.boundingBox.width,
                  height: line1.boundingBox.height
                  })
                : line2.boundingBox;

              const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
                note,
                boundingBox: newBoundingBox,
                pageIndex,
                color: wordDiff.added ? PSPDFKit.Color.GREEN : PSPDFKit.Color.RED,
                opacity: 0.5,
                rects: PSPDFKit.Immutable.List.of(newBoundingBox),
              });
      
              (wordDiff.added ? instance2 : instance1).create(highlightAnnotation);
            }
          });
      
          index1++;
          index2++;
        }
      
        while(index1 < textLines1.size) {
          const line1 = textLines1.get(index1);
      
          const newBoundingBox = new PSPDFKit.Geometry.Rect({
            ...line1.boundingBox,
            top: line1.boundingBox.top - lineShift,
          });
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line removed: "${line1.contents}"`,
            boundingBox: newBoundingBox,
            pageIndex,
            color: PSPDFKit.Color.RED,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(newBoundingBox),
          });
      
          instance1.create(highlightAnnotation);
      
          index1++;
        }
      
        while(index2 < textLines2.size) {
          const line2 = textLines2.get(index2);
      
          const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
            note: `Line added: "${line2.contents}"`,
            boundingBox: line2.boundingBox,
            pageIndex,
            color: PSPDFKit.Color.GREEN,
            opacity: 0.5,
            rects: PSPDFKit.Immutable.List.of(line2.boundingBox),
          });
      
          instance2.create(highlightAnnotation);
      
          index2++;
        }
      }
    }
    

    PSPDFKit.load({
      container: "#pspdfkitLeft",
      document: "PDF poem v1.pdf",
      toolbarItems: defaultItemsLeft,
      licenseKey: licenseKey
    })
    .then(async function(instance) {
      console.log("PSPDFKit Left loaded", instance);
      leftViewer = instance;

      // Add event listeners for the left viewer to sync its state to the right viewer
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateLeft);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
      instance.addEventListener("viewState.zoom.change", syncViewStateLeft);

      window.setTimeout(() => {
        if (leftViewer && rightViewer) {
          compareText(leftViewer, rightViewer);
          compareTextAI(leftViewer, rightViewer);
        }
      }, 250);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    PSPDFKit.load({
      container: "#pspdfkitRight",
      document: "PDF poem v3.pdf",
      toolbarItems: defaultItemsRight,
      licenseKey: licenseKey

    })
    .then(async function(instance) {
      console.log("PSPDFKit Right loaded", instance);
      rightViewer = instance;

      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateRight);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
      instance.addEventListener("viewState.zoom.change", syncViewStateRight);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    function syncViewStateLeft() {

      let scrollElementR = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementR.removeEventListener("scroll", syncViewStateRight);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: leftViewer.viewState.currentPageIndex,
        zoomLevel: leftViewer.viewState.zoom,
        scrollLeft: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = rightViewer.viewState;
      rightViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      rightViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementR.addEventListener("scroll", syncViewStateRight);
      }, 0);
    }

    function syncViewStateRight() {

      let scrollElementL = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementL.removeEventListener("scroll", syncViewStateLeft);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: rightViewer.viewState.currentPageIndex,
        zoomLevel: rightViewer.viewState.zoom,
        scrollLeft: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = leftViewer.viewState;
      leftViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      leftViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementL.addEventListener("scroll", syncViewStateLeft);
      }, 0);
      
    }
  </script>

 

</body>
</html>
