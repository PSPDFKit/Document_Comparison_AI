
<html>
<head>
  <title>PSPDFKit Document Comparison V3</title>
</head>
<style>
  #viewer-container {
    display: flex;
    height: 100vh;
  }

  #viewer-container > div {
    width: 50%;
    height: 100%;
  }
</style>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

  <script src="./assets/pspdfkit.js"></script>
  <div id="viewer-container">
    <div id="pspdfkitLeft"></div>
    <div id="pspdfkitRight"></div>
  </div>


  <script>

    let licenseKey = 'vCR5dwIXsXHZsHQoufWEefkm8URHmt9zBymfQ5rWYpggjx_xYADpAXOHYxcdt_PbwurRb_c52uN5BrbRl0ta5wnVrcTnfSM4jASkm6QuPPiuhEI0xdglf_s-V-4aFMCK9u9XT0vJ3XPU4zyiMdem6Wd5sNvUEfP_fWPsbm1DnRMAJJl3vmXshBTlGtjlJYXwNn69OkOq6K9q7qGFHIx95iCXSQLSjRfpyEtWr0wjwLlUykC7tIt9qX8oGO-STn6hplnJzRWRFs_EdP4-YqzcLMaaY-GMKnOUSU5wrThJ7Bb6LJEWBTRX2XraeB6UFqM0rwMqcso8CnoDq1l3Qn_aNZS_6wmcj3K1azVL8NuMyBmu87nwzwlegvXjSqWIXHptd_FUqXX3Npze4CymDYNoRJuJy8s3bv1ikBvXkMKwQR8d1ayy8fs9tzcRyWamyzfzsCNjv1duLSGIkluTxIZMeYU2hd3nsFsFY7Bnot2MLGZI2udJ7iIFTx3QBS_zRFdQjJ_FLl9viOFVtjG_Rklfzqvn2675leoU7de7DBUOnUWQk8oZRUAvMmber1GzORnKeE1M37Wd5YxS20tQYrjRNr0BdaTOMEUshCyCI1EEjWrCy_zdlng2l2jZtrlYZkNsEwiGz8Cvn9UtmgVHg0UQPfzDYB8tk7Hv51rh5RR9xEllaFZMc82py7G_GjSHIRLyKJWiD_eaHbWxPEnzZszNhmqpA6Jx4Y-jVAPE-bub3LG6dd5nfzCHlbMOJTiNPHrSayPmX3QRTV14MpDcyRu8uZGhalXvx3IYcMPx_SLEXattbzdcT6OWH6nFmmrztq63pJ2IgnfDbeZ0XlarWKu0SYEMAq8fBl41tFFVYdztD6PU2qULlY3SyTQyL_FnQxw4oSgFTBXeyr80Mlj03FZf710WxYF1-JuWUQq4GlOlknuXqmVdjgCF4R__lKm0IPr0xCvTq4r5f9t7zXP3LT12QcQ5QtRXPi6By11pZMkTlKGbfzRbDuf2ksVAMhOSuPmYf3C-xZBdPGvm6r95ltSFxIdYNILrwJ2IjYs2RW3JxDWFpwK4MYpEiADzQP3SiKBgqKncfTcInoFmd5kM8mFddavDbw4uoaNLIUaSXphq_qgucHk5LQP7sHFjzfqVVWxYR_U6_NUZyvpUn-1Wv6YO9K5JzeR-lnCTxOxPIE-iA01qDhj2lZ-sJYy_zK0D19uPk9b8agtDudqWlQPebCtc6cHpfe3Wq16rlwiFheL4pVI=';

    let leftViewer, rightViewer;
    let defaultItemsLeft = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsLeft.pop();
    
    let defaultItemsRight = PSPDFKit.defaultToolbarItems;
    for(let i = 0; i < 25; i++)
      defaultItemsRight.pop();

    const uploadLeft = {
      type: "custom",
      id: "UploadLeft",
      title: "Upload Left Document",
      onPress: (event) => {
        if(leftViewer){
            // Create a new file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';

            // Listen for changes to the file input element
            fileInput.addEventListener('change', (event) => {
              const file = event.target.files[0];

              // Unload the old document
              PSPDFKit.unload("#pspdfkitLeft");

              // Read the file
              const reader = new FileReader();
              reader.onload = async (event) => {
                // Load the new document
                leftViewer = await PSPDFKit.load({
                  container: "#pspdfkitLeft",
                  document: event.target.result,
                  toolbarItems: defaultItemsLeft,
                  licenseKey: licenseKey
                });

                // Delete all annotations in the other viewer
                // and compare the documents again.
                const totalPageCount = rightViewer.totalPageCount;
                for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                  const annotations = await rightViewer.getAnnotations(pageIndex);
                  rightViewer.delete(annotations);
                }
                
                // Add event listeners for the left viewer to sync its state to the right viewer
                let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
                scrollElement.addEventListener("scroll", syncViewStateLeft);

                // TODO: Needed when viewer is in single page mode
                //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
                leftViewer.addEventListener("viewState.zoom.change", syncViewStateLeft);

                compareText(leftViewer, rightViewer);
              };
              reader.readAsArrayBuffer(file);
            });

            // Open the file selector
            fileInput.click();
          }
      }
    };

    const uploadRight = {
      type: "custom",
      id: "UploadRight",
      title: "Upload Right Document",
      onPress: (event) => {
        if(rightViewer){
          // Create a new file input element
          const fileInput = document.createElement('input');
          fileInput.type = 'file';

          // Listen for changes to the file input element
          fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            // Unload the old document
            PSPDFKit.unload("#pspdfkitRight");

            // Read the file
            const reader = new FileReader();
            reader.onload = async (event) => {
              // Load the new document
              rightViewer = await PSPDFKit.load({
                container: "#pspdfkitRight",
                document: event.target.result,
                toolbarItems: defaultItemsRight,
                licenseKey: licenseKey
              });
              // Delete all annotations in the other viewer
              // and compare the documents again.
              const totalPageCount = leftViewer.totalPageCount;
              for(let pageIndex = 0; pageIndex < totalPageCount; pageIndex++) {
                const annotations = await leftViewer.getAnnotations(pageIndex);
                leftViewer.delete(annotations);
              }

              let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
              scrollElement.addEventListener("scroll", syncViewStateRight);
        
              // TODO: Needed when viewer is in single page mode
              //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
              rightViewer.addEventListener("viewState.zoom.change", syncViewStateRight);

              compareText(leftViewer, rightViewer);
            };
            reader.readAsArrayBuffer(file);
          });

          // Open the file selector
          fileInput.click();
        }
      }
    };

    defaultItemsLeft.push(uploadLeft);
    defaultItemsRight.push(uploadRight);

    function simplifyArray(originalArray) {
      let simplifiedArray = [];
    
      for (let i = 0; i < originalArray.length; i++) {
        const originalItem = originalArray[i];
        const simplifiedItem = {
          //pageNumber: 0, // Assuming all items are from page number 0
          //lines: {
            lineText: originalItem.lineText,
            lineNumber: i // Using array index as line number, starting at 0
          //}
        };
        simplifiedArray.push(simplifiedItem);
      }
    
      return simplifiedArray;
    }
    

    // Sample FNV-1a hash function for simplicity
    function hashFnv32a(str) {
      let hval = 0x811c9dc5;
      for (let i = 0; i < str.length; ++i) {
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
      }
      return hval >>> 0;
    }

    // Simhash implementation
    function simhash(text) {
      const features = text.split(/\s+/);  // naive tokenization by whitespace
      const bitLength = 32;  // using 32-bit hash function
      const v = new Array(bitLength).fill(0);

      for (const feature of features) {
        const hash = hashFnv32a(feature);
        for (let i = 0; i < bitLength; i++) {
          const mask = 1 << i;
          v[i] += (hash & mask) ? 1 : -1;
        }
      }

      let fingerprint = 0;
      for (let i = 0; i < bitLength; i++) {
        if (v[i] > 0) {
          fingerprint |= 1 << i;
        }
      }

      return fingerprint >>> 0;
    }

    // Function to calculate Simhash for each page of a document
    function calculatePageSimhash(pageLines) {
      let pageSimhash;
      let pageText;

      for (const pageLine of pageLines) {
        //const pageNumber = page.pageNumber;
        //let pageText = pageLine;
        //for (const line in page) {
          //if (line !== 'pageNumber') {
            pageText += pageLine.lineText + ' ';
          //}
        //}
        const hash = simhash(pageText.trim());
        pageSimhash = hash;
      }

      return pageSimhash;
    }

    function combinePagesToSinglePage(lines) {

      let currentLineNumber = 0; // Initialize line number for the new combined page
      let pageText = "";

      // Loop through each line in the current page
      for (const lineNumber in lines) {
        // Check if the property is a lineText object (skip pageHash and pageNumber)
        if (lines[lineNumber].hasOwnProperty('lineText')) {
          pageText += lines[lineNumber].lineText;
          currentLineNumber++;  // Increment the line number for the next line
        }
      }
      
    
      return pageText;
    }    

    async function compareTextAI(instance1, instance2) {

      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      let documentText1 = [];
      let documentText2 = [];

       // Calculate Simhash for each page
       //const pageSimhashes1 = calculatePageSimhash(documentText1);
       //console.log('Simhash for document 1:', pageSimhashes1);

      // Get the text for the left document
      for(let pageIndex = 0; pageIndex < totalPageCountLeft; pageIndex++) {
        const textLines1 = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex)
        ]);

        // Get glyphs for each instance with their position in CSV format
        let glyphs1 = await instance1.getPageGlyphs(pageIndex);
        let glyphFormatted1 = getFormattedGlyps(glyphs1);
        let linesInstance1 = await instance1.textLinesForPageIndex(pageIndex);

        let textStructure1 = buildTextStructure(linesInstance1.toArray(), glyphFormatted1);
        let simplifiedStructure1 = simplifyArray(textStructure1);
        const pageSimhashes1 = calculatePageSimhash(simplifiedStructure1);
        //console.log('Simhash for document 2:', pageSimhashes1);

        let pageText = combinePagesToSinglePage(simplifiedStructure1);

        documentText1.push({
          pageHash: pageSimhashes1,
          pageNumber: pageIndex,
          //...simplifiedStructure1
          pageText
        });

      }

      // Get the text for the right document
      for(let pageIndex = 0; pageIndex < totalPageCountRight; pageIndex++) {
        const textLines2 = await Promise.all([
          instance2.textLinesForPageIndex(pageIndex)
        ]);

        // Get glyphs for each instance with their position in CSV format
        let glyphs2 = await instance2.getPageGlyphs(pageIndex);
        let glyphFormatted2 = getFormattedGlyps(glyphs2);
        let linesInstance2 = await instance2.textLinesForPageIndex(pageIndex);

        let textStructure2 = buildTextStructure(linesInstance2.toArray(), glyphFormatted2);
        let simplifiedStructure2 = simplifyArray(textStructure2);

        let pageText = combinePagesToSinglePage(simplifiedStructure2);

        // Calculate Simhash for each page
        const pageSimhashes2 = calculatePageSimhash(simplifiedStructure2);
        //console.log('Simhash for document 2:', pageSimhashes2);

        documentText2.push({
          pageHash: pageSimhashes2,
          pageNumber: pageIndex,
          //...simplifiedStructure2
          pageText
        });
      }

      let documentTextJSON1 = JSON.stringify(documentText1);
      let documentTextJSON2 = JSON.stringify(documentText2);

      //console.log("Document Text 1:");
      //console.log(JSON.stringify(documentText1));
      //console.log(documentText1);

      //console.log("Document Text 2:");
      //console.log(documentTextJSON2);
      //console.log(documentText2);

     const instructions = "your job is to parse two CSVs and compare them, they have the following format: <character>,<top position>,<left position>,<width>,<height> put the words and sentences based on the character together, the characters are in reading order. for example this P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10; translates to 'PDFs' after parsing both CSVs, compare the text of both CSVs and tell me if there are differences. your output should be in teh format of pspdfkit web highlight annotations. i want to create as few highlight annotations as possible to show all changes in the document. remember that th format for pspdfkit highlight annotations is as follows: {pageIndex: 0,rects: boundingBoxes,boundingBox: PSPDFKit.Geometry.Rect.union(boundingBoxes)} please group highlight annotations for neighbouring changed characters together into one as long as they are in the same word, don't list them as seperate rects in an array, but actually calculate one new rect. here is an example annotation  { pageIndex: 0, color : new PSPDFKit.Color({ r: 0, g: 255, b: 255 }), boundingBox: new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 }), rects: new PSPDFKit.Immutable.List([new PSPDFKit.Geometry.Rect({ left: 82, bottom: 92, right: 101, top: 79, width: 17, height: 13 })]) }); your output should be strictly a json object with array element for each highlight annotation containing only the left, bottom, right, top, width and height property for each annotation only, without new lines \n or any other text, for example: { 'left': 74, 'bottom': 92, 'right': 112, 'top': 79, 'width': 38, 'height': 13 } start the annotation json with this keyword: 'annot:'" ;
     const userContent = "CSV1: P,74,79,8,13;D,84,79,10,13;F,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;i,133,78,2,13;t,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;CSV2: P,74,79,8,13;B,84,79,10,13;A,96,79,7,13;s,105,82,6,10;,,112,89,3,5; ,117,71,5,20;d,122,78,8,14;x,133,78,2,13;g,137,82,8,13;i,147,78,2,13;t,151,80,6,12;a,158,82,7,10;l,168,78,2,14; ,171,71,5,20;d,177,78,8,14;o,187,82,9,10;c,198,82,7,10;s,206,82,6,10; ,213,71,5,20;s,218,82,6,10;o,226,82,9,10; ,236,71,5,20;f,241,78,6,14;i,248,78,2,13;n,253,82,8,9;e,263,82,8,10;,,272,89,3,5;,275,91,0,0;";


      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer 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'
        },
        body: JSON.stringify({
          "model": "gpt-4",
          "temperature": 0,
          "messages": [
          {
            "role": "system",
            "content": instructions,
          },
            {
              "role": "user",
              "content": "CSV1: " + glyphFormatted1 + " CSV2: " + glyphFormatted2,
              //"content": userContent,
            }
          ]
        })
      })
      .then(async response => {
        let resp = await response.json();
        consol.log("response");
        console.log(resp);
      });
        /*let message = resp["choices"][0]["message"]["content"];
        console.log(message);

        // Extract the JSON part from the string
        let jsonPart = message.split("annot:")[1];
        jsonPart = jsonPart.replace(/'/g, '"');
        console.log("json part: ");
        console.log(jsonPart);

        const regex = /annot: {.*?}(?=\n|$)/g;
        const annotations = [];

        let match;
        while ((match = regex.exec(message)) !== null) {
            // Remove the "annot: " prefix and parse the JSON
            const jsonPart = match[0].replace("annot: ", "");
            try {
                const parsed = JSON.parse(jsonPart.replace(/'/g, "\"")); // Replacing single quotes with double quotes
                annotations.push(parsed);
            } catch (err) {
                console.error("Failed to parse JSON", err);
            }
        }

        console.log(annotations);

        // Parse the JSON part to a JavaScript object
        //let jsonArray = JSON.parse(jsonPart);

        if (!Array.isArray(annotations)) {
          annotations = [annotations];
      }

        // Loop through each JSON element and create a new HighlightAnnotation
        annotations.forEach(rect => {
          let annotation = new PSPDFKit.Annotations.HighlightAnnotation({
            pageIndex: 0,
            color: new PSPDFKit.Color({ r: 0, g: 255, b: 255 }),
            boundingBox: new PSPDFKit.Geometry.Rect({
              left: rect.left,
              bottom: rect.bottom,
              right: rect.right,
              top: rect.top,
              width: rect.width,
              height: rect.height
            }),
            rects: new PSPDFKit.Immutable.List([
              new PSPDFKit.Geometry.Rect({
                left: rect.left,
                bottom: rect.bottom,
                right: rect.right,
                top: rect.top,
                width: rect.width,
                height: rect.height
              })
            ])
          });
          // Use your PSPDFKit instance to create the annotation
          // Replace 'instance1' with your actual instance name
          instance1.create(annotation)
            .then(() => {
              console.log("Annotation created");
            })
            .catch(err => {
              console.error("Error creating annotation:", err);
            });
        });


        // Now `annotations` is an array of objects that you can import into PSPDFKit
        //console.log("creating this annot");
        //console.log(annotations);
        

        //wait instance1.create(annotations);
        //console.log("annot created");
      })
      .then(data => console.log(data))
      .catch((error) => console.error('Error:', error));*/



    }

    function getFormattedGlyps(glyphs){

      function truncateNumbers(obj) {
        if (typeof obj === "number") {
          return parseFloat(obj.toFixed(0));
        } else if (typeof obj === "object" && obj !== null) {
          if (Array.isArray(obj)) {
            return obj.map(item => truncateNumbers(item));
          } else {
            const newObj = {};
            for (const key in obj) {
              newObj[key] = truncateNumbers(obj[key]);
            }
            return newObj;
          }
        }
        return obj;
      }
    
      // Assuming you have the flattened array
      const flattenedArray = glyphs.toArray();
    
      // Truncate numbers to two decimal points
      const truncatedArray = truncateNumbers(flattenedArray);
    
      // Convert the truncated array to a JSON string
      const jsonString = JSON.stringify(truncatedArray);
    
      // Log or use the JSON string as needed
      //console.log(jsonString);
  

      const optimizedJson = truncatedArray.map(item => {
        const { c, rect } = item;
        let width = rect.get("width");
        let height = rect.get("height");
        let top = rect.get("top");
        let left = rect.get("left");
        return { c, width, height, top, left };
      });

      return optimizedJson;
    
      //console.log(JSON.stringify(optimizedJson, null, 2));
    
      // Create the formatted string
      /*let result = '';
      for (const item of optimizedJson) {
        const char = item.c;
        const left = truncateNumbers(item.rect.toJS().left);
        const top = truncateNumbers(item.rect.toJS().top);
        const width = truncateNumbers(item.rect.toJS().width);
        const height = truncateNumbers(item.rect.toJS().height);
    
        //result += `${char},${left},${top};`;
        // Check for newline or carriage return and replace with their names
        if (char === '\n') {
          result += `\n,${left},${top},${width},${height};`;
        } else if (char === '\r') {
          result += `\r,${left},${top},${width},${height};`;
        } else {
           result += `${char},${left},${top},${width},${height};`;
           //result += `${char},${width};`;
        }
      }
    
      // Remove the trailing semicolon
      result = result.slice(0, -1);
      return result;*/
    }

    function buildTextStructure(pageLines, characters) {
      const structure = [];
  
      function isCharInLine(char, line) {
          return char.top >= line.boundingBox.top && char.top <= line.boundingBox.bottom;
      }
  
      for (const line of pageLines) {
          const lineStructure = {
              lineText: line.contents,
              boundingBox: line.boundingBox,
              words: []
          };
  
          let wordsFromLineText = line.contents.split(/\s+/);
          let wordIndex = 0;
  
          let currentWord = {
              wordText: '',
              boundingBox: null,
              characters: []
          };
  
          let lastChar = null;
  
          for (let i = 0; i < characters.length; i++) {
              const char = characters[i];
              const isLastChar = i === characters.length - 1 || !isCharInLine(characters[i + 1], line);
  
              if (isCharInLine(char, line)) {
                  // Add the character to the current word
                  currentWord.wordText += char.c;
                  currentWord.characters.push(char);
  
                  // Update bounding box
                  if (currentWord.boundingBox === null) {
                      currentWord.boundingBox = {
                          height: line.boundingBox.height,
                          top: line.boundingBox.top,
                          left: char.left,
                          width: char.width
                      };
                  } else {
                      const charRight = char.left + char.width;
                      const currentWordRight = currentWord.boundingBox.left + currentWord.boundingBox.width;
                      if (charRight > currentWordRight) {
                          currentWord.boundingBox.width = charRight - currentWord.boundingBox.left;
                      }
                  }
  
                  // Check if the currentWord matches the word from lineText
                  if (currentWord.wordText === wordsFromLineText[wordIndex]) {
                      lineStructure.words.push(currentWord);
                      wordIndex++; // Move to next word
  
                      // Reset the current word
                      currentWord = {
                          wordText: '',
                          boundingBox: null,
                          characters: []
                      };
                  }
  
                  lastChar = char;
              }
          }
  
          structure.push(lineStructure);
      }
  
      return structure;
  }
  
    async function compareText(instance1, instance2){
      const totalPageCountLeft = instance1.totalPageCount;
      const totalPageCountRight = instance2.totalPageCount;

      const smallerPageCount = Math.min(totalPageCountLeft, totalPageCountRight);

      function createHighlightAnnotation(boundingBox, type, pageIndex, instance) {
        const color = type === 'DELETE' ? PSPDFKit.Color.RED : PSPDFKit.Color.GREEN;
        const note = type === 'DELETE' ? `Deleted` : `Inserted`;
        pageIndex = 0;
        const highlightAnnotation = new PSPDFKit.Annotations.HighlightAnnotation({
          //note,
          boundingBox: new PSPDFKit.Geometry.Rect(boundingBox), // Use the boundingBox parameter here.
          pageIndex,
          color,
          opacity: 0.5,
          rects: PSPDFKit.Immutable.List.of(new PSPDFKit.Geometry.Rect(boundingBox))
        });
      

          instance.create(highlightAnnotation);
      }
      
      async function compareDocuments(doc1, doc2, instance1, instance2) {
        const pageIndex = 0;
      
        let i = 0, j = 0;
        while (i < doc1.length || j < doc2.length) {
          const line1 = doc1[i];
          const line2 = doc2[j];
      
          // Both lines are the same, proceed to the next line in both documents
          if (line1 && line2 && line1.lineText === line2.lineText) {
            i++;
            j++;
            continue;
          }
      
          // If we encounter different lines, we check for line shifts
          let lineShiftDetected = false;
      
          // Check if the current line in doc1 appears further down in doc2
          for (let k = j + 1; k < doc2.length; k++) {
            if (line1 && line1.lineText === doc2[k].lineText) {
              // Highlight lines in doc2[j:k] as 'INSERT'
              for (let l = j; l < k; l++) {
                createHighlightAnnotation(doc2[l].boundingBox, 'INSERT', pageIndex, instance2);
              }
              j = k;
              lineShiftDetected = true;
              break;
            }
          }
      
          // Check if the current line in doc2 appears further down in doc1
          if (!lineShiftDetected) {
            for (let k = i + 1; k < doc1.length; k++) {
              if (line2 && line2.lineText === doc1[k].lineText) {
                // Highlight lines in doc1[i:k] as 'DELETE'
                for (let l = i; l < k; l++) {
                  createHighlightAnnotation(doc1[l].boundingBox, 'DELETE', pageIndex, instance1);
                }
                i = k;
                lineShiftDetected = true;
                break;
              }
            }
          }
      
          // If no line shift is detected, we compare the words in the lines
          if (!lineShiftDetected) {
            if (line1 && line2) {
              compareWords(line1, line2, pageIndex, instance1, instance2);
            } else if (line1) {
              createHighlightAnnotation(line1.boundingBox, 'DELETE', pageIndex, instance1);
            } else if (line2) {
              createHighlightAnnotation(line2.boundingBox, 'INSERT', pageIndex, instance2);
            }
      
            i++;
            j++;
          }
        }
      }

      function compareWords(line1, line2, pageIndex, instance1, instance2) {
        let words1 = line1.words;
        let words2 = line2.words;
      
        let i = 0, j = 0;
        while (i < words1.length && j < words2.length) {
          let word1 = words1[i];
          let word2 = words2[j];
      
          if (word1.wordText === word2.wordText) {
            i++;
            j++;
            continue;
          }
      
          if (word1 && word2) {
            let differingCharacters = compareCharacters(word1, word2);
            if (differingCharacters.length <= 2) {
              // Highlight individual characters if only two or less are different
              for (const [char1, char2] of differingCharacters) {
                let boundingBoxChar1 = {
                  top: word1.boundingBox.top,
                  left: char1.left,
                  width: char1.width,
                  height: word1.boundingBox.height
                }
                let boundingBoxChar2 = {
                  top: word2.boundingBox.top,
                  left: char2.left,
                  width: char2.width,
                  height: word2.boundingBox.height
                }

                createHighlightAnnotation(boundingBoxChar1, 'DELETE', pageIndex, instance1);
                createHighlightAnnotation(boundingBoxChar2, 'INSERT', pageIndex, instance2);
              }
            } else {
              // Highlight entire word if more than two characters are different
              createHighlightAnnotation(word1.boundingBox, 'DELETE', pageIndex, instance1);
              createHighlightAnnotation(word2.boundingBox, 'INSERT', pageIndex, instance2);
            }
            i++;
            j++;
          }
        }
      }
      
      function compareCharacters(word1, word2) {
        let chars1 = word1.characters;
        let chars2 = word2.characters;
      
        let differingCharacters = [];
        let minLength = Math.min(chars1.length, chars2.length);
      
        for (let i = 0; i < minLength; i++) {
          let char1 = chars1[i];
          let char2 = chars2[i];
      
          if (char1.c !== char2.c) {
            differingCharacters.push([char1, char2]);
          }
        }
      
        // Handle any remaining characters if the lengths of the two words are different
        if (chars1.length !== chars2.length) {
          for (let i = minLength; i < Math.max(chars1.length, chars2.length); i++) {
            if (chars1[i]) {
              differingCharacters.push([chars1[i], null]);
            }
            if (chars2[i]) {
              differingCharacters.push([null, chars2[i]]);
            }
          }
        }
      
        return differingCharacters;
      }
      
      for(let pageIndex = 0; pageIndex < smallerPageCount; pageIndex++) {
        const [textLines1, textLines2] = await Promise.all([
          instance1.textLinesForPageIndex(pageIndex),
          instance2.textLinesForPageIndex(pageIndex),
        ]);
      
          let index1 = 0, index2 = 0;
          let lineShift = 0;

        // Get glyphs for each instance with their position in CSV format
        let glyphs1 = await instance1.getPageGlyphs(0);
        let glyphFormatted1 = getFormattedGlyps(glyphs1);

        let glyphs2 = await instance2.getPageGlyphs(0);
        let glyphFormatted2 = getFormattedGlyps(glyphs2);

        console.log("Instance 1: ");
        console.log(glyphFormatted1);
        //console.log("Instance 2: ");
        //console.log(glyphFormatted2);

        console.log("text lines1");
        console.log(textLines1.toArray());

        const pageTextStructured1 = buildTextStructure(textLines1.toArray(), glyphFormatted1);
        const pageTextStructured2 = buildTextStructure(textLines2.toArray(), glyphFormatted2);
        console.log("pageTextStructured1");
        console.log(pageTextStructured1);
        console.log("pageTextStructured2");
        console.log(pageTextStructured2);

        compareDocuments(pageTextStructured1, pageTextStructured2, instance1, instance2);

      }

    }

    PSPDFKit.load({
      container: "#pspdfkitLeft",
      document: "PDF poem v5.pdf",
      toolbarItems: defaultItemsLeft,
      licenseKey: licenseKey
    })
    .then(async function(instance) {
      console.log("PSPDFKit Left loaded", instance);
      leftViewer = instance;

      // Add event listeners for the left viewer to sync its state to the right viewer
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateLeft);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState);
      instance.addEventListener("viewState.zoom.change", syncViewStateLeft);

      window.setTimeout(() => {
        if (leftViewer && rightViewer) {
          compareText(leftViewer, rightViewer);
          compareTextAI(leftViewer, rightViewer, 0);
        }
      }, 250);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    PSPDFKit.load({
      container: "#pspdfkitRight",
      document: "PDF poem v4.pdf",
      toolbarItems: defaultItemsRight,
      licenseKey: licenseKey

    })
    .then(async function(instance) {
      console.log("PSPDFKit Right loaded", instance);
      rightViewer = instance;

      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.addEventListener("scroll", syncViewStateRight);

      // TODO: Needed when viewer is in single page mode
      //instance.addEventListener("viewState.currentPageIndex.change", syncViewState2);
      instance.addEventListener("viewState.zoom.change", syncViewStateRight);

    })
    .catch(function(error) {
      console.error(error.message);
    });

    function syncViewStateLeft() {

      let scrollElementR = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementR.removeEventListener("scroll", syncViewStateRight);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: leftViewer.viewState.currentPageIndex,
        zoomLevel: leftViewer.viewState.zoom,
        scrollLeft: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = rightViewer.viewState;
      rightViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      rightViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementR.addEventListener("scroll", syncViewStateRight);
      }, 0);
    }

    function syncViewStateRight() {

      let scrollElementL = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElementL.removeEventListener("scroll", syncViewStateLeft);

      // This is the data that needs to be send over to the other
      // viewer, e.g. via WebSockets.
      
      // Get the current view state from the left viewer
      let customViewState = {
        pageNumber: rightViewer.viewState.currentPageIndex,
        zoomLevel: rightViewer.viewState.zoom,
        scrollLeft: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollLeft,
        scrollTop: rightViewer.contentDocument.querySelector(".PSPDFKit-Scroll").scrollTop,
      };
    
      // Set the page number
      let viewState = leftViewer.viewState;
      leftViewer.setViewState(viewState.set("currentPageIndex", customViewState.pageNumber));
    
      // Set the zoom level
      leftViewer.setViewState(viewState.set("zoom", customViewState.zoomLevel));
    
      // Set scroll position
      let scrollElement = leftViewer.contentDocument.querySelector(".PSPDFKit-Scroll");
      scrollElement.scrollLeft = customViewState.scrollLeft;
      scrollElement.scrollTop = customViewState.scrollTop;

      window.setTimeout(() => {
        scrollElementL.addEventListener("scroll", syncViewStateLeft);
      }, 0);
      
    }
  </script>

 

</body>
</html>
